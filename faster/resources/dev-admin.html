<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dev Admin Dashboard</title>

    <!-- External Dependencies -->
    <link
      href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js"
      defer
    ></script>
    <script
      src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"
      defer
    ></script>
    <script
      src="https://js.sentry-cdn.com/d2a200c0751f88c697a50ea7adb176e8.min.js"
      defer
      crossorigin="anonymous"
      id="sentry-script"
      onload="window.sentryLoaded = true; window.dispatchEvent(new Event('sentryReady'));"
      onerror="window.sentryLoadFailed = true;"
    ></script>

    <!-- Alpine.js -->
    <script
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
      defer
    ></script>

    <!-- Generated API Client -->
    <script
      src="/dev/client_api_fetch.js"
      defer
      onload="window.apiClientLoaded = true;"
      onerror="window.apiClientLoadFailed = true; console.error('Failed to load API client script');"
    ></script>

    <style>
      /* Core Styles */
      [x-cloak] {
        display: none !important;
      }

      /* Component Styles */
      .dropdown-content .menu-item-active {
        background-color: hsl(var(--p) / 0.1);
        color: hsl(var(--p));
        font-weight: 600;
      }

      .page-transition {
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
      }

      .page-enter {
        opacity: 0;
        transform: translateY(-10px);
      }

      .page-enter-active {
        opacity: 1;
        transform: translateY(0);
      }

      /* Loading States */
      .loading-overlay {
        background-color: hsl(var(--b1) / 0.9);
        backdrop-filter: blur(4px);
      }
    </style>
  </head>

  <body
    class="bg-base-100 min-h-screen"
    x-data="app.devAdminApp()"
    x-init="init()"
  >
    <!-- Global Components -->
    <div
      x-data="app.toastManager()"
      x-show="$store.toast.show"
      x-transition
      class="toast toast-end z-50"
      role="alert"
      aria-live="polite"
    >
      <div class="alert" :class="$store.toast.class">
        <i
          :data-lucide="$store.toast.icon"
          class="w-5 h-5"
          aria-hidden="true"
        ></i>
        <span x-text="$store.toast.message"></span>
      </div>
    </div>

    <!-- Loading Screen -->
    <div
      x-show="$store.app.currentView === 'loading'"
      class="loading-overlay fixed inset-0 flex items-center justify-center"
      x-cloak
    >
      <div class="text-center">
        <div
          class="loading loading-spinner loading-lg text-primary"
          aria-label="Loading"
        ></div>
        <p class="mt-4 text-base-content" x-text="$store.app.loadingMessage">
          Initializing...
        </p>
      </div>
    </div>

    <!-- Authentication View -->
    <div
      x-show="$store.app.currentView === 'auth'"
      class="min-h-screen bg-base-200 flex items-center justify-center p-4"
      x-cloak
    >
      <div class="card w-full max-w-md bg-base-100 shadow-xl">
        <div class="card-body">
          <header class="text-center mb-6">
            <h1 class="card-title justify-center">
              <i
                data-lucide="shield-check"
                class="w-6 h-6 text-primary"
                aria-hidden="true"
              ></i>
              Dev Admin Login
            </h1>
          </header>

          <div x-data="app.authComponent()">
            <!-- OAuth Login Options -->
            <div class="space-y-3 mb-4">
              <template x-for="provider in oauthProviders" :key="provider.id">
                <button
                  @click="signInWithOAuth(provider.id)"
                  :disabled="$store.auth.loading"
                  class="btn btn-outline btn-block"
                  :aria-label="`Continue with ${provider.name}`"
                >
                  <i
                    :data-lucide="provider.icon"
                    class="w-5 h-5"
                    aria-hidden="true"
                  ></i>
                  <span x-text="`Continue with ${provider.name}`"></span>
                </button>
              </template>
            </div>

            <div class="divider">OR</div>

            <!-- Email/Password Form -->
            <form @submit.prevent="handleEmailSubmit" class="space-y-4">
              <div class="form-control">
                <label class="label" for="email-input">
                  <span class="label-text">Email</span>
                </label>
                <input
                  id="email-input"
                  x-model="formData.email"
                  type="email"
                  placeholder="Enter your email"
                  class="input input-bordered"
                  :class="{ 'input-error': formErrors.email }"
                  required
                  autocomplete="email"
                  :disabled="$store.auth.loading"
                />
                <div class="label" x-show="formErrors.email">
                  <span
                    class="label-text-alt text-error"
                    x-text="formErrors.email"
                  ></span>
                </div>
              </div>

              <div class="form-control">
                <label class="label" for="password-input">
                  <span class="label-text">Password</span>
                </label>
                <input
                  id="password-input"
                  x-model="formData.password"
                  type="password"
                  placeholder="Enter your password"
                  class="input input-bordered"
                  :class="{ 'input-error': formErrors.password }"
                  required
                  autocomplete="current-password"
                  :disabled="$store.auth.loading"
                />
                <div class="label" x-show="formErrors.password">
                  <span
                    class="label-text-alt text-error"
                    x-text="formErrors.password"
                  ></span>
                </div>
              </div>

              <button
                type="submit"
                :disabled="$store.auth.loading"
                class="btn btn-primary btn-block"
                :class="{ 'loading': $store.auth.loading }"
              >
                <template x-if="!$store.auth.loading">
                  <i
                    :data-lucide="isSignUp ? 'user-plus' : 'log-in'"
                    class="w-5 h-5"
                    aria-hidden="true"
                  ></i>
                </template>
                <span x-text="isSignUp ? 'Sign Up' : 'Sign In'"></span>
              </button>
            </form>

            <!-- Sign Up Toggle -->
            <div class="text-center mt-4">
              <button @click="toggleSignUp()" class="link link-primary text-sm">
                <span
                  x-text="isSignUp ? 'Already have an account? Sign in' : 'Need an account? Sign up'"
                ></span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Application -->
    <div x-show="$store.app.currentView === 'app'" class="min-h-screen" x-cloak>
      <!-- Navigation Header -->
      <nav
        class="navbar bg-base-100 shadow-lg"
        role="navigation"
        aria-label="Main navigation"
      >
        <div class="navbar-start">
          <h1 class="text-xl font-bold text-primary">
            <i
              data-lucide="code"
              class="w-6 h-6 inline mr-2"
              aria-hidden="true"
            ></i>
            <span class="sr-only">Dev Admin Dashboard</span>
            Dev Admin
          </h1>
        </div>

        <div class="navbar-end">
          <!-- Theme Toggle -->
          <div class="mr-2" x-data="app.themeToggle()" x-init="init()">
            <button
              @click="toggle()"
              class="btn btn-ghost btn-circle"
              title="Toggle theme"
              aria-label="Toggle between light and dark theme"
            >
              <i
                :data-lucide="isDark ? 'sun' : 'moon'"
                class="w-5 h-5"
                aria-hidden="true"
              ></i>
            </button>
          </div>

          <!-- User Menu -->
          <div class="dropdown dropdown-end" x-data="app.userMenu()">
            <div
              tabindex="0"
              role="button"
              class="btn btn-ghost btn-circle avatar placeholder"
              aria-label="User menu"
            >
              <div class="w-10 rounded-full bg-neutral text-neutral-content">
                <img
                  x-show="hasAvatar()"
                  :src="getAvatarUrl()"
                  class="rounded-full"
                  alt="User Avatar"
                  loading="lazy"
                />
                <span
                  x-show="!hasAvatar()"
                  class="text-xl"
                  x-text="getInitials()"
                  aria-label="User initials"
                ></span>
              </div>
            </div>

            <ul
              tabindex="0"
              class="mt-3 z-[1] p-2 shadow menu menu-sm dropdown-content bg-base-100 rounded-box w-52"
              role="menu"
            >
              <template x-for="item in menuItems" :key="item.id">
                <li role="none">
                  <a
                    @click.prevent="selectMenuItem(item)"
                    href="#"
                    :class="item.id === $store.app.currentPage ? 'menu-item-active' : ''"
                    role="menuitem"
                    :aria-current="item.id === $store.app.currentPage ? 'page' : null"
                  >
                    <i
                      :data-lucide="item.icon"
                      class="w-4 h-4"
                      aria-hidden="true"
                    ></i>
                    <span x-text="item.label"></span>
                  </a>
                </li>
              </template>
              <li role="none"><hr class="my-2" /></li>
              <li role="none">
                <button
                  @click="signOut()"
                  class="text-error flex items-center w-full text-left px-4 py-2 hover:bg-base-200"
                  role="menuitem"
                >
                  <i
                    data-lucide="log-out"
                    class="w-4 h-4 mr-2"
                    aria-hidden="true"
                  ></i>
                  Logout
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Main Content -->
      <main class="container mx-auto p-4" x-data="app.pageManager()">
        <div
          class="page-transition"
          :class="{ 'page-enter': isTransitioning, 'page-enter-active': !isTransitioning }"
        >
          <!-- Profile Page -->
          <template x-if="$store.app.currentPage === 'profile'">
            <div x-data="app.profilePage()" x-cloak>
              <div class="max-w-4xl mx-auto space-y-6">
                <!-- Profile Header -->
                <div class="card bg-base-100 shadow-xl">
                  <div class="card-body">
                    <div class="flex flex-col md:flex-row items-center gap-6">
                      <div class="avatar">
                        <div
                          class="w-24 h-24 rounded-full ring ring-primary ring-offset-base-100 ring-offset-2"
                        >
                          <img
                            :src="getUserAvatarUrl()"
                            :alt="`${getUserDisplayName()}'s avatar`"
                            loading="lazy"
                          />
                        </div>
                      </div>
                      <div class="text-center md:text-left flex-1">
                        <h1
                          class="text-3xl font-bold"
                          x-text="getUserDisplayName()"
                        ></h1>
                        <p
                          class="text-base-content/70 text-lg"
                          x-text="getUserEmail()"
                        ></p>
                        <div class="flex flex-wrap gap-2 mt-3">
                          <template x-for="role in getUserRoles()" :key="role">
                            <span
                              class="badge badge-primary"
                              x-text="formatRole(role)"
                            ></span>
                          </template>
                          <span
                            x-show="!getUserRoles().length"
                            class="badge badge-neutral"
                            >No roles assigned</span
                          >
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Profile Information Grid -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  <!-- Personal Information -->
                  <div class="card bg-base-100 shadow-xl">
                    <div class="card-body">
                      <h2 class="card-title">
                        <i
                          data-lucide="user"
                          class="w-5 h-5"
                          aria-hidden="true"
                        ></i>
                        Personal Information
                      </h2>
                      <div class="space-y-4">
                        <template
                          x-for="field in personalFields"
                          :key="field.id"
                        >
                          <div class="form-control">
                            <label class="label">
                              <span
                                class="label-text font-semibold"
                                x-text="field.label"
                              ></span>
                            </label>
                            <div
                              class="bg-base-200 p-3 rounded-lg flex items-center gap-2"
                            >
                              <span
                                x-text="field.value || 'Not provided'"
                              ></span>
                              <template x-if="field.badge">
                                <span
                                  :class="`badge badge-${field.badge.type} badge-sm`"
                                  x-text="field.badge.text"
                                ></span>
                              </template>
                            </div>
                          </div>
                        </template>
                      </div>
                    </div>
                  </div>

                  <!-- Account Information -->
                  <div class="card bg-base-100 shadow-xl">
                    <div class="card-body">
                      <h2 class="card-title">
                        <i
                          data-lucide="settings"
                          class="w-5 h-5"
                          aria-hidden="true"
                        ></i>
                        Account Information
                      </h2>
                      <div class="space-y-4">
                        <template
                          x-for="field in accountFields"
                          :key="field.id"
                        >
                          <div class="form-control">
                            <label class="label">
                              <span
                                class="label-text font-semibold"
                                x-text="field.label"
                              ></span>
                            </label>
                            <div
                              :class="field.mono ? 'bg-base-200 p-3 rounded-lg font-mono text-sm' : 'bg-base-200 p-3 rounded-lg flex items-center gap-2'"
                            >
                              <span x-text="field.value"></span>
                              <template x-if="field.icon">
                                <i
                                  :data-lucide="field.icon"
                                  class="w-4 h-4 text-success"
                                  aria-hidden="true"
                                ></i>
                              </template>
                            </div>
                          </div>
                        </template>
                      </div>
                    </div>
                  </div>

                  <!-- Password Management -->
                  <div class="card bg-base-100 shadow-xl">
                    <div class="card-body">
                      <h2 class="card-title">
                        <i
                          data-lucide="lock"
                          class="w-5 h-5"
                          aria-hidden="true"
                        ></i>
                        Password Management
                      </h2>
                      <div class="space-y-4">
                        <!-- Change Password -->
                        <div class="form-control">
                          <label class="label">
                            <span class="label-text font-semibold"
                              >Change Password</span
                            >
                          </label>
                          <div class="flex gap-2">
                            <button
                              @click="showPasswordChangeModal = true"
                              class="btn btn-outline btn-primary"
                            >
                              <i data-lucide="key" class="w-4 h-4"></i>
                              Change Password
                            </button>
                          </div>
                        </div>

                        <!-- Password Reset -->
                        <div class="form-control">
                          <label class="label">
                            <span class="label-text font-semibold"
                              >Password Reset</span
                            >
                          </label>
                          <div class="flex gap-2">
                            <button
                              @click="initiatePasswordReset()"
                              class="btn btn-outline btn-secondary"
                              :class="{ 'loading': passwordResetLoading }"
                              :disabled="passwordResetLoading"
                            >
                              <i data-lucide="mail" class="w-4 h-4"></i>
                              Send Reset Email
                            </button>
                          </div>
                          <div class="label">
                            <span class="label-text-alt text-base-content/60">
                              Send a password reset email to your account
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- Account Operations -->
                  <div class="card bg-base-100 shadow-xl">
                    <div class="card-body">
                      <h2 class="card-title text-error">
                        <i
                          data-lucide="alert-triangle"
                          class="w-5 h-5"
                          aria-hidden="true"
                        ></i>
                        Account Operations
                      </h2>
                      <div class="alert alert-warning mb-4">
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        <div>
                          <h3 class="font-bold">Danger Zone</h3>
                          <div class="text-xs">
                            These operations are irreversible. Please proceed
                            with caution.
                          </div>
                        </div>
                      </div>
                      <div class="space-y-4">
                        <!-- Deactivate Account -->
                        <div class="form-control">
                          <label class="label">
                            <span class="label-text font-semibold"
                              >Deactivate Account</span
                            >
                          </label>
                          <div class="flex gap-2">
                            <button
                              @click="showDeactivateModal = true"
                              class="btn btn-outline btn-warning"
                            >
                              <i data-lucide="user-x" class="w-4 h-4"></i>
                              Deactivate Account
                            </button>
                          </div>
                          <div class="label">
                            <span class="label-text-alt text-warning">
                              Deactivate your account and all associated data.
                              This action cannot be easily undone.
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Profile Modals -->
              <!-- Password Change Modal -->
              <template x-if="showPasswordChangeModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg">
                      <i data-lucide="key" class="w-5 h-5 inline mr-2"></i>
                      Change Password
                    </h3>
                    <form @submit.prevent="changePassword" class="py-4">
                      <div class="form-control">
                        <label class="label" for="new-password">
                          <span class="label-text">New Password</span>
                        </label>
                        <input
                          id="new-password"
                          x-model="passwordForm.new"
                          type="password"
                          placeholder="Enter new password"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="confirm-password">
                          <span class="label-text">Confirm New Password</span>
                        </label>
                        <input
                          id="confirm-password"
                          x-model="passwordForm.confirm"
                          type="password"
                          placeholder="Confirm new password"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="alert alert-info mt-4">
                        <i data-lucide="info" class="w-4 h-4"></i>
                        <span class="text-sm"
                          >Your password will be updated immediately. Make sure
                          to remember your new password.</span
                        >
                      </div>
                    </form>
                    <div class="modal-action">
                      <button
                        @click="showPasswordChangeModal = false; resetPasswordForm()"
                        class="btn"
                      >
                        Cancel
                      </button>
                      <button
                        @click="changePassword()"
                        class="btn btn-primary"
                        :class="{ 'loading': passwordChangeLoading }"
                        :disabled="passwordChangeLoading"
                      >
                        Change Password
                      </button>
                    </div>
                  </div>
                </div>
              </template>

              <!-- Password Recovery Modal -->
              <template x-if="$store.app.showPasswordRecoveryModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg">
                      <i
                        data-lucide="key-round"
                        class="w-5 h-5 inline mr-2"
                      ></i>
                      Reset Your Password
                    </h3>
                    <form
                      @submit.prevent="completePasswordRecovery"
                      class="py-4"
                    >
                      <div class="form-control">
                        <label class="label" for="recovery-password">
                          <span class="label-text">New Password</span>
                        </label>
                        <input
                          id="recovery-password"
                          x-model="recoveryForm.password"
                          type="password"
                          placeholder="Enter new password"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="recovery-confirm">
                          <span class="label-text">Confirm New Password</span>
                        </label>
                        <input
                          id="recovery-confirm"
                          x-model="recoveryForm.confirm"
                          type="password"
                          placeholder="Confirm new password"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="alert alert-info mt-4">
                        <i data-lucide="info" class="w-4 h-4"></i>
                        <span class="text-sm"
                          >Enter your new password to complete the reset
                          process.</span
                        >
                      </div>
                    </form>
                    <div class="modal-action">
                      <button
                        @click="$store.app.showPasswordRecoveryModal = false; resetRecoveryForm()"
                        class="btn"
                      >
                        Cancel
                      </button>
                      <button
                        @click="completePasswordRecovery()"
                        class="btn btn-primary"
                        :class="{ 'loading': passwordRecoveryLoading }"
                        :disabled="passwordRecoveryLoading"
                      >
                        Reset Password
                      </button>
                    </div>
                  </div>
                </div>
              </template>

              <!-- Deactivate Account Modal -->
              <template x-if="showDeactivateModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg text-warning">
                      <i data-lucide="user-x" class="w-5 h-5 inline mr-2"></i>
                      Deactivate Account
                    </h3>
                    <div class="py-4">
                      <div class="alert alert-warning">
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        <div>
                          <h4 class="font-bold">
                            Are you sure you want to deactivate your account?
                          </h4>
                          <div class="text-sm">
                            This will deactivate your account and all associated
                            data including profile, roles, and metadata. This
                            action cannot be easily undone and you won't be able
                            to access the system.
                          </div>
                        </div>
                      </div>
                      <div class="form-control mt-4">
                        <label class="label cursor-pointer">
                          <span class="label-text"
                            >I understand the consequences</span
                          >
                          <input
                            type="checkbox"
                            x-model="deactivateConfirmed"
                            class="checkbox checkbox-warning"
                          />
                        </label>
                      </div>
                    </div>
                    <div class="modal-action">
                      <button
                        @click="showDeactivateModal = false; deactivateConfirmed = false"
                        class="btn"
                      >
                        Cancel
                      </button>
                      <button
                        @click="deactivateAccount()"
                        class="btn btn-warning"
                        :class="{ 'loading': deactivateLoading }"
                        :disabled="deactivateLoading || !deactivateConfirmed"
                      >
                        Deactivate Account
                      </button>
                    </div>
                  </div>
                </div>
              </template>
            </div>
          </template>

          <!-- User Management Page -->
          <template x-if="$store.app.currentPage === 'user-management'">
            <div x-data="app.userManagementPage()" x-cloak>
              <div class="max-w-4xl mx-auto space-y-6">
                <!-- User Management Header -->
                <div class="card bg-base-100 shadow-xl">
                  <div class="card-body">
                    <h1 class="card-title">
                      <i
                        data-lucide="users"
                        class="w-6 h-6"
                        aria-hidden="true"
                      ></i>
                      User Management
                    </h1>
                    <p class="text-base-content/70">
                      Manage user accounts, roles, and permissions
                    </p>
                  </div>
                </div>

                <!-- User Search and Actions -->
                <div class="card bg-base-100 shadow-xl">
                  <div class="card-body">
                    <h2 class="card-title">
                      <i
                        data-lucide="search"
                        class="w-5 h-5"
                        aria-hidden="true"
                      ></i>
                      User Lookup
                    </h2>

                    <!-- User ID/Email Input with Search Button -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text font-semibold"
                          >Target User ID/Email</span
                        >
                      </label>
                      <div class="relative">
                        <input
                          x-model="targetUserId"
                          @input="validateUserInput()"
                          @keydown.enter="viewUserBasicInfo()"
                          type="text"
                          placeholder="Enter user ID (UUID format) or email address"
                          class="input input-bordered w-full pr-12"
                          :class="{ 'input-error': userIdError }"
                          title="Please enter a valid UUID format or email address"
                          autocomplete="off"
                          spellcheck="false"
                        />
                        <!-- Search Icon Button -->
                        <button
                          @click="viewUserBasicInfo()"
                          class="absolute right-2 top-1/2 transform -translate-y-1/2 btn btn-ghost btn-sm btn-circle"
                          :class="{ 'loading': viewBasicInfoLoading }"
                          :disabled="viewBasicInfoLoading || !targetUserId.trim()"
                          title="Search user information"
                        >
                          <i
                            data-lucide="search"
                            class="w-4 h-4"
                            x-show="!viewBasicInfoLoading"
                          ></i>
                        </button>
                      </div>
                      <div class="label" x-show="userIdError">
                        <span
                          class="label-text-alt text-error"
                          x-text="userIdError"
                        ></span>
                      </div>
                      <div
                        class="label"
                        x-show="!userIdError && targetUserId.length > 0"
                      >
                        <span class="label-text-alt text-success"
                          >âœ“ Valid UUID format or email address</span
                        >
                      </div>
                    </div>

                    <!-- Action Buttons (Only shown after user info is loaded) -->
                    <div
                      x-show="canShowActionButtons()"
                      class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-6"
                    >
                      <!-- Ban/Unban User -->
                      <div class="form-control">
                        <button
                          x-show="shouldShowBanButton()"
                          @click="showBanConfirmModal = true"
                          class="btn btn-outline btn-error"
                          :class="{ 'loading': banLoading }"
                          :disabled="banLoading"
                        >
                          <i data-lucide="user-x" class="w-4 h-4"></i>
                          Ban User
                        </button>
                        <button
                          x-show="shouldShowUnbanButton()"
                          @click="showUnbanConfirmModal = true"
                          class="btn btn-outline btn-success"
                          :class="{ 'loading': unbanLoading }"
                          :disabled="unbanLoading"
                        >
                          <i data-lucide="user-check" class="w-4 h-4"></i>
                          Unban User
                        </button>
                      </div>

                      <!-- Adjust Roles -->
                      <div class="form-control">
                        <button
                          @click="openAdjustRolesModal()"
                          class="btn btn-outline btn-primary"
                          :disabled="!canShowActionButtons()"
                        >
                          <i data-lucide="settings" class="w-4 h-4"></i>
                          Adjust Roles
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- User Information Display -->
                <div x-show="userInfo" class="card bg-base-100 shadow-xl">
                  <div class="card-body">
                    <h2 class="card-title">
                      <i
                        data-lucide="user"
                        class="w-5 h-5"
                        aria-hidden="true"
                      ></i>
                      User Information
                    </h2>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div class="form-control">
                        <label class="label">
                          <span class="label-text font-semibold">User ID</span>
                        </label>
                        <div
                          class="bg-base-200 p-3 rounded-lg font-mono text-sm"
                          x-text="userInfo?.id || 'N/A'"
                        ></div>
                      </div>

                      <div class="form-control">
                        <label class="label">
                          <span class="label-text font-semibold">Email</span>
                        </label>
                        <div
                          class="bg-base-200 p-3 rounded-lg"
                          x-text="userInfo?.email || 'N/A'"
                        ></div>
                      </div>

                      <div class="form-control">
                        <label class="label">
                          <span class="label-text font-semibold">Status</span>
                        </label>
                        <div
                          class="bg-base-200 p-3 rounded-lg flex items-center gap-2"
                        >
                          <span x-text="userInfo?.status || 'Unknown'"></span>
                          <div
                            class="badge"
                            :class="userInfo?.status === 'active' ? 'badge-success' : userInfo?.status === 'banned' ? 'badge-error' : 'badge-warning'"
                          >
                            <span x-text="userInfo?.status || 'Unknown'"></span>
                          </div>
                        </div>
                      </div>

                      <div class="form-control">
                        <label class="label">
                          <span class="label-text font-semibold">Roles</span>
                        </label>
                        <div class="bg-base-200 p-3 rounded-lg">
                          <div
                            x-show="userInfo?.roles && userInfo?.roles.length > 0"
                            class="flex flex-wrap gap-2"
                          >
                            <template
                              x-for="role in userInfo?.roles || []"
                              :key="role"
                            >
                              <span
                                class="badge badge-primary"
                                x-text="role"
                              ></span>
                            </template>
                          </div>
                          <span
                            x-show="!userInfo?.roles || userInfo?.roles.length === 0"
                            class="text-base-content/60"
                            >No roles assigned</span
                          >
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- User Management Modals -->
              <!-- Adjust Roles Modal -->
              <template x-if="showAdjustRolesModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg">
                      <i data-lucide="settings" class="w-5 h-5 inline mr-2"></i>
                      Adjust User Roles
                    </h3>
                    <div class="py-4">
                      <p class="text-sm text-base-content/70 mb-4">
                        Select the roles for user
                        <span
                          class="font-mono text-xs"
                          x-text="targetUserId"
                        ></span>
                      </p>
                      <div class="space-y-3">
                        <template
                          x-for="role in getAvailableRoles()"
                          :key="role"
                        >
                          <label class="label cursor-pointer">
                            <span class="label-text" x-text="role"></span>
                            <input
                              type="checkbox"
                              class="checkbox checkbox-primary"
                              :checked="isRoleSelected(role)"
                              @change="toggleRole(role)"
                            />
                          </label>
                        </template>
                      </div>
                      <div
                        x-show="selectedRoles.length === 0"
                        class="alert alert-warning mt-4"
                      >
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        <span>Please select at least one role</span>
                      </div>
                    </div>
                    <div class="modal-action">
                      <button
                        @click="showAdjustRolesModal = false; selectedRoles = []"
                        class="btn"
                      >
                        Cancel
                      </button>
                      <button
                        @click="adjustRoles()"
                        class="btn btn-primary"
                        :class="{ 'loading': adjustRolesLoading }"
                        :disabled="adjustRolesLoading || selectedRoles.length === 0"
                      >
                        Update Roles
                      </button>
                    </div>
                  </div>
                </div>
              </template>

              <!-- Ban User Confirmation Modal -->
              <template x-if="showBanConfirmModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg text-error">
                      <i data-lucide="user-x" class="w-5 h-5 inline mr-2"></i>
                      Ban User
                    </h3>
                    <div class="py-4">
                      <div class="alert alert-warning">
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        <div>
                          <h4 class="font-bold">
                            Are you sure you want to ban this user?
                          </h4>
                          <div class="text-sm">
                            User ID:
                            <span class="font-mono" x-text="targetUserId"></span
                            ><br />
                            This action will prevent the user from accessing the
                            system.
                          </div>
                        </div>
                      </div>
                    </div>
                    <div class="modal-action">
                      <button @click="showBanConfirmModal = false" class="btn">
                        Cancel
                      </button>
                      <button
                        @click="banUser()"
                        class="btn btn-error"
                        :class="{ 'loading': banLoading }"
                        :disabled="banLoading"
                      >
                        Ban User
                      </button>
                    </div>
                  </div>
                </div>
              </template>

              <!-- Unban User Confirmation Modal -->
              <template x-if="showUnbanConfirmModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg text-success">
                      <i
                        data-lucide="user-check"
                        class="w-5 h-5 inline mr-2"
                      ></i>
                      Unban User
                    </h3>
                    <div class="py-4">
                      <div class="alert alert-info">
                        <i data-lucide="info" class="w-5 h-5"></i>
                        <div>
                          <h4 class="font-bold">
                            Are you sure you want to unban this user?
                          </h4>
                          <div class="text-sm">
                            User ID:
                            <span class="font-mono" x-text="targetUserId"></span
                            ><br />
                            This action will restore the user's access to the
                            system.
                          </div>
                        </div>
                      </div>
                    </div>
                    <div class="modal-action">
                      <button
                        @click="showUnbanConfirmModal = false"
                        class="btn"
                      >
                        Cancel
                      </button>
                      <button
                        @click="unbanUser()"
                        class="btn btn-success"
                        :class="{ 'loading': unbanLoading }"
                        :disabled="unbanLoading"
                      >
                        Unban User
                      </button>
                    </div>
                  </div>
                </div>
              </template>
            </div>
          </template>

          <!-- App State Page -->
          <div
            x-show="$store.app.currentPage === 'app-state'"
            x-data="app.appStatePage()"
            x-cloak
          >
            <div class="max-w-7xl mx-auto space-y-6">
              <!-- App State Header -->
              <div class="navbar bg-base-100 shadow-lg rounded-box">
                <div class="navbar-start">
                  <div class="flex items-center gap-3">
                    <div class="avatar">
                      <div
                        class="w-10 h-10 rounded-lg bg-gradient-to-br from-accent to-secondary flex items-center justify-center"
                      >
                        <i
                          data-lucide="terminal"
                          class="w-5 h-5 text-accent-content"
                          aria-hidden="true"
                        ></i>
                      </div>
                    </div>
                    <div>
                      <h1
                        class="text-xl font-bold"
                        x-text="getPageTitle()"
                      ></h1>
                      <p
                        class="text-sm text-base-content/60"
                        x-text="getPageDescription()"
                      ></p>
                    </div>
                  </div>
                </div>
                <div class="navbar-end">
                  <div class="flex gap-2">
                    <div class="dropdown dropdown-end">
                      <div
                        tabindex="0"
                        role="button"
                        class="btn btn-ghost btn-sm"
                      >
                        <i
                          data-lucide="download"
                          class="w-4 h-4"
                          aria-hidden="true"
                        ></i>
                        Export
                      </div>
                      <ul
                        tabindex="0"
                        class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52"
                      >
                        <li>
                          <a @click="exportAsJSON()"
                            ><i data-lucide="file-text" class="w-4 h-4"></i>
                            JSON</a
                          >
                        </li>
                        <li>
                          <a @click="copyToClipboard()"
                            ><i data-lucide="copy" class="w-4 h-4"></i> Copy</a
                          >
                        </li>
                      </ul>
                    </div>
                    <button
                      @click="loadHealthData()"
                      class="btn btn-primary btn-sm"
                      :class="{ 'loading': loading }"
                      :disabled="loading"
                    >
                      <i
                        data-lucide="refresh-cw"
                        class="w-4 h-4"
                        aria-hidden="true"
                      ></i>
                      <span x-show="!loading">Refresh</span>
                    </button>
                  </div>
                </div>
              </div>

              <!-- Code Editor Interface -->
              <div
                x-show="appStateData && Object.keys(appStateData).length > 0"
                class="mockup-window border-2 border-base-300 bg-base-100 shadow-2xl"
              >
                <div class="flex justify-center px-4 py-4 bg-base-200">
                  <!-- Code Editor Mockup -->
                  <div class="w-full">
                    <!-- Editor Header -->
                    <div
                      class="flex items-center justify-between bg-base-100 px-4 py-2 border-b border-base-300"
                    >
                      <div class="flex items-center gap-2">
                        <div class="flex gap-1">
                          <div class="w-3 h-3 rounded-full bg-error"></div>
                          <div class="w-3 h-3 rounded-full bg-warning"></div>
                          <div class="w-3 h-3 rounded-full bg-success"></div>
                        </div>
                        <span class="text-sm font-mono text-base-content/60"
                          >app_state.json</span
                        >
                      </div>
                      <div class="flex items-center gap-2">
                        <div class="badge badge-sm badge-accent">Live</div>
                        <span
                          class="text-xs text-base-content/40"
                          x-text="formatTimestamp()"
                        ></span>
                      </div>
                    </div>

                    <!-- Line Numbers & Code -->
                    <div class="flex bg-base-100">
                      <!-- Line Numbers -->
                      <div
                        class="bg-base-200 px-4 py-4 text-xs font-mono text-base-content/40 select-none min-w-[60px] border-r border-base-300 overflow-auto max-h-[500px]"
                      >
                        <template x-for="line in getLineNumbers()" :key="line">
                          <div class="leading-6 text-right" x-text="line"></div>
                        </template>
                      </div>

                      <!-- Code Content -->
                      <div class="flex-1 p-4 overflow-auto max-h-[500px]">
                        <pre
                          class="text-sm font-mono leading-6 text-base-content"
                          x-html="formatAppStateDataWithSyntax()"
                        ></pre>
                      </div>
                    </div>

                    <!-- Editor Footer -->
                    <div
                      class="flex items-center justify-between bg-base-200 px-4 py-2 border-t border-base-300 text-xs"
                    >
                      <div class="flex items-center gap-4">
                        <span class="flex items-center gap-1">
                          <i data-lucide="type" class="w-3 h-3"></i>
                          JSON
                        </span>
                        <span class="flex items-center gap-1">
                          <i data-lucide="file-text" class="w-3 h-3"></i>
                          <span x-text="getDataSize()"></span>
                        </span>
                      </div>
                      <div class="flex items-center gap-4">
                        <span x-text="getObjectCount()"></span>
                        <div class="flex items-center gap-1">
                          <div class="w-2 h-2 rounded-full bg-success"></div>
                          <span>Ready</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Loading State -->
              <div
                x-show="loading && (!appStateData || Object.keys(appStateData).length === 0)"
                class="card bg-base-100 shadow-xl"
              >
                <div class="card-body items-center text-center">
                  <div
                    class="loading loading-spinner loading-lg text-primary"
                  ></div>
                  <h3 class="text-lg font-semibold mt-4">
                    Loading Application State
                  </h3>
                  <p class="text-base-content/60">
                    Fetching real-time data from server...
                  </p>
                </div>
              </div>

              <!-- Empty State -->
              <div
                x-show="!loading && (!appStateData || Object.keys(appStateData).length === 0) && !error"
                class="hero bg-base-200 rounded-box"
              >
                <div class="hero-content text-center py-20">
                  <div class="max-w-md">
                    <div class="mockup-code mb-6 bg-base-100">
                      <pre
                        data-prefix="$"
                      ><code>curl /dev/app_state</code></pre>
                      <pre
                        data-prefix=">"
                        class="text-warning"
                      ><code>No data found</code></pre>
                    </div>
                    <h3 class="text-2xl font-bold">No Application State</h3>
                    <p class="py-4 text-base-content/70">
                      The application state endpoint returned no data. This
                      could be normal during startup or maintenance.
                    </p>
                    <button
                      @click="loadHealthData()"
                      class="btn btn-primary"
                      :class="{ 'loading': loading }"
                      :disabled="loading"
                    >
                      <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                      Check Again
                    </button>
                  </div>
                </div>
              </div>

              <!-- Error State -->
              <div x-show="error" class="alert alert-error shadow-lg">
                <div class="flex items-start gap-3">
                  <i
                    data-lucide="alert-triangle"
                    class="w-6 h-6 flex-shrink-0"
                    aria-hidden="true"
                  ></i>
                  <div class="flex-1">
                    <h3 class="font-bold text-lg">Connection Error</h3>
                    <div class="text-sm opacity-80 mt-1" x-text="error"></div>
                    <div class="mt-3">
                      <button
                        @click="loadHealthData()"
                        class="btn btn-sm btn-ghost"
                      >
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                        Retry
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Request State Page -->
          <div
            x-show="$store.app.currentPage === 'request-state'"
            x-data="app.requestStatePage()"
            x-cloak
          >
            <div class="max-w-7xl mx-auto space-y-6">
              <!-- Request State Header -->
              <div class="navbar bg-base-100 shadow-lg rounded-box">
                <div class="navbar-start">
                  <div class="flex items-center gap-3">
                    <div class="avatar">
                      <div
                        class="w-10 h-10 rounded-lg bg-gradient-to-br from-accent to-secondary flex items-center justify-center"
                      >
                        <i
                          data-lucide="send"
                          class="w-5 h-5 text-accent-content"
                          aria-hidden="true"
                        ></i>
                      </div>
                    </div>
                    <div>
                      <h1
                        class="text-xl font-bold"
                        x-text="getPageTitle()"
                      ></h1>
                      <p
                        class="text-sm text-base-content/60"
                        x-text="getPageDescription()"
                      ></p>
                    </div>
                  </div>
                </div>
                <div class="navbar-end">
                  <div class="flex gap-2">
                    <div class="dropdown dropdown-end">
                      <div
                        tabindex="0"
                        role="button"
                        class="btn btn-ghost btn-sm"
                      >
                        <i
                          data-lucide="download"
                          class="w-4 h-4"
                          aria-hidden="true"
                        ></i>
                        Export
                      </div>
                      <ul
                        tabindex="0"
                        class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52"
                      >
                        <li>
                          <a @click="exportAsJSON()"
                            ><i data-lucide="file-text" class="w-4 h-4"></i>
                            JSON</a
                          >
                        </li>
                        <li>
                          <a @click="copyToClipboard()"
                            ><i data-lucide="copy" class="w-4 h-4"></i> Copy</a
                          >
                        </li>
                      </ul>
                    </div>
                    <button
                      @click="loadHealthData()"
                      class="btn btn-primary btn-sm"
                      :class="{ 'loading': loading }"
                      :disabled="loading"
                    >
                      <i
                        data-lucide="refresh-cw"
                        class="w-4 h-4"
                        aria-hidden="true"
                      ></i>
                      <span x-show="!loading">Refresh</span>
                    </button>
                  </div>
                </div>
              </div>

              <!-- Code Editor Interface -->
              <div
                x-show="requestStateData && Object.keys(requestStateData).length > 0"
                class="mockup-window border-2 border-base-300 bg-base-100 shadow-2xl"
              >
                <div class="flex justify-center px-4 py-4 bg-base-200">
                  <!-- Code Editor Mockup -->
                  <div class="w-full">
                    <!-- Editor Header -->
                    <div
                      class="flex items-center justify-between bg-base-100 px-4 py-2 border-b border-base-300"
                    >
                      <div class="flex items-center gap-2">
                        <div class="flex gap-1">
                          <div class="w-3 h-3 rounded-full bg-error"></div>
                          <div class="w-3 h-3 rounded-full bg-warning"></div>
                          <div class="w-3 h-3 rounded-full bg-success"></div>
                        </div>
                        <span class="text-sm font-mono text-base-content/60"
                          >request_state.json</span
                        >
                      </div>
                      <div class="flex items-center gap-2">
                        <div class="badge badge-sm badge-accent">Live</div>
                        <span
                          class="text-xs text-base-content/40"
                          x-text="formatTimestamp()"
                        ></span>
                      </div>
                    </div>

                    <!-- Line Numbers & Code -->
                    <div class="flex bg-base-100">
                      <!-- Line Numbers -->
                      <div
                        class="bg-base-200 px-4 py-4 text-xs font-mono text-base-content/40 select-none min-w-[60px] border-r border-base-300 overflow-auto max-h-[500px]"
                      >
                        <template x-for="line in getLineNumbers()" :key="line">
                          <div class="leading-6 text-right" x-text="line"></div>
                        </template>
                      </div>

                      <!-- Code Content -->
                      <div class="flex-1 p-4 overflow-auto max-h-[500px]">
                        <pre
                          class="text-sm font-mono leading-6 text-base-content"
                          x-html="formatRequestStateDataWithSyntax()"
                        ></pre>
                      </div>
                    </div>

                    <!-- Editor Footer -->
                    <div
                      class="flex items-center justify-between bg-base-200 px-4 py-2 border-t border-base-300 text-xs"
                    >
                      <div class="flex items-center gap-4">
                        <span class="flex items-center gap-1">
                          <i data-lucide="type" class="w-3 h-3"></i>
                          JSON
                        </span>
                        <span class="flex items-center gap-1">
                          <i data-lucide="file-text" class="w-3 h-3"></i>
                          <span x-text="getDataSize()"></span>
                        </span>
                      </div>
                      <div class="flex items-center gap-4">
                        <span x-text="getObjectCount()"></span>
                        <div class="flex items-center gap-1">
                          <div class="w-2 h-2 rounded-full bg-success"></div>
                          <span>Ready</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Loading State -->
              <div
                x-show="loading && (!requestStateData || Object.keys(requestStateData).length === 0)"
                class="card bg-base-100 shadow-xl"
              >
                <div class="card-body items-center text-center">
                  <div
                    class="loading loading-spinner loading-lg text-primary"
                  ></div>
                  <h3 class="text-lg font-semibold mt-4">
                    Loading Request State
                  </h3>
                  <p class="text-base-content/60">
                    Fetching real-time request data from server...
                  </p>
                </div>
              </div>

              <!-- Empty State -->
              <div
                x-show="!loading && (!requestStateData || Object.keys(requestStateData).length === 0) && !error"
                class="hero bg-base-200 rounded-box"
              >
                <div class="hero-content text-center py-20">
                  <div class="max-w-md">
                    <div class="mockup-code mb-6 bg-base-100">
                      <pre
                        data-prefix="$"
                      ><code>curl /dev/request_state</code></pre>
                      <pre
                        data-prefix=">"
                        class="text-warning"
                      ><code>No data found</code></pre>
                    </div>
                    <h3 class="text-2xl font-bold">No Request State</h3>
                    <p class="py-4 text-base-content/70">
                      The request state endpoint returned no data. This could be
                      normal during startup or maintenance.
                    </p>
                    <button
                      @click="loadHealthData()"
                      class="btn btn-primary"
                      :class="{ 'loading': loading }"
                      :disabled="loading"
                    >
                      <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                      Check Again
                    </button>
                  </div>
                </div>
              </div>

              <!-- Error State -->
              <div x-show="error" class="alert alert-error shadow-lg">
                <div class="flex items-start gap-3">
                  <i
                    data-lucide="alert-triangle"
                    class="w-6 h-6 flex-shrink-0"
                    aria-hidden="true"
                  ></i>
                  <div class="flex-1">
                    <h3 class="font-bold text-lg">Connection Error</h3>
                    <div class="text-sm opacity-80 mt-1" x-text="error"></div>
                    <div class="mt-3">
                      <button
                        @click="loadHealthData()"
                        class="btn btn-sm btn-ghost"
                      >
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                        Retry
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Sys Health Page -->
          <div
            x-show="$store.app.currentPage === 'sys-health'"
            x-data="app.sysHealthPage()"
            x-cloak
          >
            <div class="max-w-7xl mx-auto space-y-6">
              <!-- Sys Health Header -->
              <div class="navbar bg-base-100 shadow-lg rounded-box">
                <div class="navbar-start">
                  <div class="flex items-center gap-3">
                    <div class="avatar">
                      <div
                        class="w-10 h-10 rounded-lg bg-gradient-to-br from-accent to-secondary flex items-center justify-center"
                      >
                        <i
                          data-lucide="heart-pulse"
                          class="w-5 h-5 text-accent-content"
                          aria-hidden="true"
                        ></i>
                      </div>
                    </div>
                    <div>
                      <h1 class="text-xl font-bold">System Health</h1>
                      <p class="text-sm text-base-content/60">
                        Monitor plugin status and health metrics
                      </p>
                    </div>
                  </div>
                </div>
                <div class="navbar-end">
                  <div class="flex gap-2">
                    <button
                      @click="loadHealthData()"
                      class="btn btn-primary btn-sm"
                      :class="{ 'loading': loading }"
                      :disabled="loading"
                    >
                      <i
                        data-lucide="refresh-cw"
                        class="w-4 h-4"
                        aria-hidden="true"
                      ></i>
                      <span x-show="!loading">Refresh</span>
                    </button>
                  </div>
                </div>
              </div>

              <!-- Plugin Health Status Cards -->
              <div
                x-show="healthData && Object.keys(healthData).length > 0"
                class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"
              >
                <template
                  x-for="[pluginName, pluginHealth] in (healthData ? Object.entries(healthData).filter(([key]) => !['latest_status_check'].includes(key)) : [])"
                  :key="pluginName"
                >
                  <div class="card bg-base-100 shadow-xl">
                    <div class="card-body">
                      <h2 class="card-title capitalize flex items-center gap-2">
                        <i
                          :data-lucide="getPluginIcon(pluginName)"
                          class="w-5 h-5 text-primary"
                          aria-hidden="true"
                        ></i>
                        <span x-text="pluginName.toUpperCase()"></span>
                      </h2>

                      <!-- Status Badge -->
                      <div class="flex items-center gap-2 mb-3">
                        <div
                          class="badge"
                          :class="getPluginStatus(pluginHealth).color === 'green' ? 'badge-success' : getPluginStatus(pluginHealth).color === 'red' ? 'badge-error' : 'badge-warning'"
                        >
                          <i
                            data-lucide="check-circle"
                            class="w-3 h-3 mr-1"
                            aria-hidden="true"
                          ></i>
                          <span
                            x-text="getPluginStatus(pluginHealth).status"
                          ></span>
                        </div>
                      </div>

                      <!-- Plugin Details -->
                      <div class="space-y-2 text-sm">
                        <template
                          x-for="detail in formatPluginData(pluginHealth)"
                          :key="detail.key"
                        >
                          <div class="flex justify-between">
                            <span
                              class="text-base-content/60 capitalize"
                              x-text="detail.key"
                            ></span>
                            <span
                              class="font-mono text-xs"
                              x-text="detail.value"
                            ></span>
                          </div>
                        </template>
                      </div>

                      <!-- Error Details (if any) -->
                      <div
                        x-show="getPluginStatus(pluginHealth).status === 'error'"
                        class="mt-3"
                      >
                        <div class="alert alert-error alert-sm">
                          <i
                            data-lucide="alert-triangle"
                            class="w-4 h-4"
                            aria-hidden="true"
                          ></i>
                          <span class="text-xs">Plugin has errors</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </template>
              </div>

              <!-- Loading State -->
              <div
                x-show="loading && (!healthData || Object.keys(healthData).length === 0)"
                class="card bg-base-100 shadow-xl"
              >
                <div class="card-body items-center text-center">
                  <div
                    class="loading loading-spinner loading-lg text-primary"
                  ></div>
                  <h3 class="text-lg font-semibold mt-4">
                    Loading System Health
                  </h3>
                  <p class="text-base-content/60">
                    Checking plugin status and health metrics...
                  </p>
                </div>
              </div>

              <!-- Empty State -->
              <div
                x-show="!loading && (!healthData || Object.keys(healthData).length === 0) && !error"
                class="hero bg-base-200 rounded-box"
              >
                <div class="hero-content text-center py-20">
                  <div class="max-w-md">
                    <div class="mockup-code mb-6 bg-base-100">
                      <pre data-prefix="$"><code>curl /health</code></pre>
                      <pre
                        data-prefix=">"
                        class="text-warning"
                      ><code>No data found</code></pre>
                    </div>
                    <h3 class="text-2xl font-bold">No Health Data</h3>
                    <p class="py-4 text-base-content/70">
                      The health endpoint returned no data. This could be normal
                      during startup or maintenance.
                    </p>
                    <button
                      @click="loadHealthData()"
                      class="btn btn-primary"
                      :class="{ 'loading': loading }"
                      :disabled="loading"
                    >
                      <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                      Check Again
                    </button>
                  </div>
                </div>
              </div>

              <!-- Error State -->
              <div x-show="error" class="alert alert-error shadow-lg">
                <div class="flex items-start gap-3">
                  <i
                    data-lucide="alert-triangle"
                    class="w-6 h-6 flex-shrink-0"
                    aria-hidden="true"
                  ></i>
                  <div class="flex-1">
                    <h3 class="font-bold text-lg">Health Check Error</h3>
                    <div class="text-sm opacity-80 mt-1" x-text="error"></div>
                    <div class="mt-3">
                      <button
                        @click="loadHealthData()"
                        class="btn btn-sm btn-ghost"
                      >
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                        Retry
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Onboarding Page -->
          <div
            x-show="$store.app.currentPage === 'onboarding'"
            x-data="app.onboardingPage()"
            x-cloak
          >
            <div class="max-w-4xl mx-auto space-y-8">
              <!-- Welcome Header -->
              <div class="text-center space-y-4">
                <div class="avatar">
                  <div
                    class="w-20 h-20 rounded-full bg-gradient-to-r from-primary to-secondary flex items-center justify-center"
                  >
                    <i
                      data-lucide="user-check"
                      class="w-10 h-10 text-primary-content"
                      aria-hidden="true"
                    ></i>
                  </div>
                </div>
                <h1
                  class="text-4xl font-bold text-primary"
                  x-text="getHeadlineMessage()"
                ></h1>
                <p class="text-lg text-base-content/70 max-w-2xl mx-auto">
                  Let's get you set up and ready to manage your development
                  environment. This onboarding guide will help you understand
                  the key features and get started quickly.
                </p>
              </div>

              <!-- Progress Indicator -->
              <div class="card bg-base-100 shadow-xl">
                <div class="card-body">
                  <h2 class="card-title">
                    <i
                      data-lucide="target"
                      class="w-5 h-5"
                      aria-hidden="true"
                    ></i>
                    Your Setup Progress
                  </h2>
                  <div
                    class="space-y-4"
                    role="group"
                    aria-label="Setup progress"
                  >
                    <template x-for="step in progressSteps" :key="step.id">
                      <div class="flex items-center gap-4">
                        <div class="flex-1">
                          <div class="flex justify-between text-sm mb-1">
                            <span x-text="step.label"></span>
                            <span x-text="`${step.progress}%`"></span>
                          </div>
                          <progress
                            class="progress progress-primary w-full"
                            :value="step.progress"
                            max="100"
                            :aria-label="`${step.label}: ${step.progress}% complete`"
                          ></progress>
                        </div>
                        <i
                          :data-lucide="step.progress === 100 ? 'check-circle' : 'circle'"
                          :class="step.progress === 100 ? 'w-6 h-6 text-success' : 'w-6 h-6 text-base-content/50'"
                          aria-hidden="true"
                        ></i>
                      </div>
                    </template>
                  </div>
                </div>
              </div>

              <!-- Help Footer -->
              <footer class="text-center text-base-content/60">
                <p>
                  Need help? Check the browser console for detailed logs or
                  contact your administrator.
                </p>
              </footer>
            </div>
          </div>

          <!-- RBAC Page -->
          <div
            x-show="$store.app.currentPage === 'rbac'"
            x-data="app.rbacPage()"
            x-cloak
          >
            <div class="max-w-7xl mx-auto space-y-6">
              <!-- RBAC Header -->
              <div class="navbar bg-base-100 shadow-lg rounded-box">
                <div class="navbar-start">
                  <div class="flex items-center gap-3">
                    <div class="avatar">
                      <div
                        class="w-10 h-10 rounded-lg bg-gradient-to-br from-accent to-secondary flex items-center justify-center"
                      >
                        <i
                          data-lucide="shield-check"
                          class="w-6 h-6 text-accent-content"
                          aria-hidden="true"
                        ></i>
                      </div>
                    </div>
                    <div>
                      <h1 class="text-xl font-bold text-primary">RBAC</h1>
                      <p
                        class="text-sm text-base-content/60"
                        x-text="getPageDescription()"
                      ></p>
                    </div>
                  </div>
                </div>
                <div class="navbar-end">
                  <div class="flex gap-2">
                    <button
                      @click="loadRbacData()"
                      class="btn btn-primary btn-sm"
                      :class="{ 'loading': loading }"
                      :disabled="loading"
                    >
                      <i data-lucide="refresh-cw" class="w-4 h-4 mr-1"></i>
                      Refresh
                    </button>
                    <div class="dropdown dropdown-end">
                      <div
                        tabindex="0"
                        role="button"
                        class="btn btn-ghost btn-sm"
                      >
                        <i
                          data-lucide="download"
                          class="w-4 h-4 mr-1"
                          aria-hidden="true"
                        ></i>
                        Export
                      </div>
                      <ul
                        tabindex="0"
                        class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52"
                      >
                        <li>
                          <a @click="exportAsJSON()"
                            ><i data-lucide="file-text" class="w-4 h-4"></i>
                            JSON</a
                          >
                        </li>
                        <li>
                          <a @click="copyToClipboard()"
                            ><i data-lucide="copy" class="w-4 h-4"></i> Copy</a
                          >
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Statistics Cards -->
              <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="stat bg-base-100 shadow rounded-box">
                  <div class="stat-figure text-primary">
                    <i data-lucide="route" class="w-8 h-8"></i>
                  </div>
                  <div class="stat-title">Total Routes</div>
                  <div
                    class="stat-value text-primary"
                    x-text="rbacData.cache_stats?.total_routes || 0"
                  ></div>
                  <div class="stat-desc">Registered endpoints</div>
                </div>
                <div class="stat bg-base-100 shadow rounded-box">
                  <div class="stat-figure text-secondary">
                    <i data-lucide="tags" class="w-8 h-8"></i>
                  </div>
                  <div class="stat-title">Tag-Role Mappings</div>
                  <div
                    class="stat-value text-secondary"
                    x-text="rbacData.cache_stats?.tag_role_cache_size || 0"
                  ></div>
                  <div class="stat-desc">Cached mappings</div>
                </div>
                <div class="stat bg-base-100 shadow rounded-box">
                  <div class="stat-figure text-accent">
                    <i data-lucide="database" class="w-8 h-8"></i>
                  </div>
                  <div class="stat-title">Route Cache</div>
                  <div
                    class="stat-value text-accent"
                    x-text="rbacData.cache_stats?.route_cache_size || 0"
                  ></div>
                  <div class="stat-desc">Cached routes</div>
                </div>
              </div>

              <!-- RBAC Table -->
              <div class="card bg-base-100 shadow-lg">
                <div class="card-body">
                  <div class="flex justify-between items-center mb-4">
                    <h2 class="card-title">
                      <i data-lucide="table" class="w-5 h-5 mr-2"></i>
                      Route Access Control
                    </h2>
                    <div class="flex gap-2">
                      <input
                        type="text"
                        placeholder="Search routes..."
                        class="input input-bordered input-sm w-64"
                        x-model="searchTerm"
                        @input="filterRoutes()"
                      />
                      <select
                        class="select select-bordered select-sm"
                        x-model="methodFilter"
                        @change="filterRoutes()"
                      >
                        <option value="">All Methods</option>
                        <option value="GET">GET</option>
                        <option value="POST">POST</option>
                        <option value="PUT">PUT</option>
                        <option value="DELETE">DELETE</option>
                        <option value="PATCH">PATCH</option>
                      </select>
                    </div>
                  </div>

                  <div class="overflow-x-auto">
                    <table class="table table-zebra w-full">
                      <thead>
                        <tr>
                          <th>Method</th>
                          <th>Path</th>
                          <th>Name</th>
                          <th>Tags</th>
                          <th>Allowed Roles</th>
                          <th>Access Level</th>
                        </tr>
                      </thead>
                      <tbody>
                        <template
                          x-for="route in filteredRoutes"
                          :key="route.id"
                        >
                          <tr>
                            <td>
                              <span
                                class="badge badge-sm badge-outline"
                                x-text="route.method"
                              ></span>
                            </td>
                            <td>
                              <code class="text-sm" x-text="route.path"></code>
                            </td>
                            <td x-text="route.name"></td>
                            <td>
                              <div class="flex flex-wrap gap-1">
                                <template x-for="tag in route.tags" :key="tag">
                                  <span
                                    class="badge badge-xs"
                                    :class="getTagColor(tag)"
                                    x-text="tag"
                                  ></span>
                                </template>
                                <span
                                  x-show="route.tags.length === 0"
                                  class="text-base-content/50 text-xs"
                                  >No tags</span
                                >
                              </div>
                            </td>
                            <td>
                              <div class="flex flex-wrap gap-1">
                                <template
                                  x-for="(role, index) in route.allowed_roles"
                                  :key="role"
                                >
                                  <span
                                    class="badge badge-xs"
                                    :class="getRoleColor(role, index)"
                                    x-text="role"
                                  ></span>
                                </template>
                                <span
                                  x-show="route.allowed_roles.length === 0"
                                  class="text-base-content/50 text-xs"
                                  >No roles</span
                                >
                              </div>
                            </td>
                            <td>
                              <span
                                class="badge badge-sm"
                                :class="{
                                  'badge-success': getAccessLevel(route) === 'Public',
                                  'badge-error': getAccessLevel(route) === 'Unknown',
                                  'badge-warning': getAccessLevel(route) === 'Restricted'
                                }"
                                x-text="getAccessLevel(route)"
                              ></span>
                            </td>
                          </tr>
                        </template>
                      </tbody>
                    </table>

                    <!-- Empty State -->
                    <div
                      x-show="filteredRoutes.length === 0 && !loading"
                      class="text-center py-8"
                    >
                      <i
                        data-lucide="search-x"
                        class="w-12 h-12 mx-auto text-base-content/30 mb-4"
                      ></i>
                      <p class="text-base-content/60">
                        No routes found matching your criteria
                      </p>
                    </div>

                    <!-- Loading State -->
                    <div x-show="loading" class="text-center py-8">
                      <span class="loading loading-spinner loading-lg"></span>
                      <p class="text-base-content/60 mt-4">
                        Loading RBAC data...
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Metadata Page -->
          <div
            x-show="$store.app.currentPage === 'metadata'"
            x-data="app.metadataPage()"
            x-cloak
          >
            <div class="max-w-7xl mx-auto space-y-6">
              <!-- Metadata Header -->
              <div class="card bg-base-100 shadow-xl">
                <div class="card-body">
                  <h1 class="card-title">
                    <i
                      data-lucide="database"
                      class="w-6 h-6"
                      aria-hidden="true"
                    ></i>
                    Metadata Management
                  </h1>
                  <p class="text-base-content/70">
                    Manage system dictionaries and mappings
                  </p>
                </div>
              </div>

              <!-- Sys Dict Section -->
              <div class="card bg-base-100 shadow-xl">
                <div class="card-body">
                  <h2 class="card-title">
                    <i
                      data-lucide="book"
                      class="w-5 h-5"
                      aria-hidden="true"
                    ></i>
                    System Dictionary (Sys Dict)
                  </h2>

                  <!-- Filters -->
                  <div class="flex flex-col md:flex-row gap-4 mb-4">
                    <div class="form-control w-full md:w-1/4">
                      <label class="label">
                        <span class="label-text">Category</span>
                      </label>
                      <select
                        x-model="sysDictFilters.category"
                        class="select select-bordered"
                      >
                        <option value="">All Categories</option>
                        <template
                          x-for="category in sysDictCategories"
                          :key="category"
                        >
                          <option :value="category" x-text="category"></option>
                        </template>
                      </select>
                    </div>
                    <div class="form-control w-full md:w-1/4">
                      <label class="label">
                        <span class="label-text">Key</span>
                      </label>
                      <input
                        x-model="sysDictFilters.key"
                        type="number"
                        placeholder="Filter by key"
                        class="input input-bordered"
                      />
                    </div>
                    <div class="form-control w-full md:w-5/12">
                      <label class="label">
                        <span class="label-text">Value</span>
                      </label>
                      <input
                        x-model="sysDictFilters.value"
                        type="text"
                        placeholder="Filter by value"
                        class="input input-bordered"
                      />
                    </div>
                    <div class="form-control w-full md:w-1/6">
                      <label class="label">
                        <span class="label-text">Status</span>
                      </label>
                      <select
                        x-model="sysDictFilters.status"
                        class="select select-bordered"
                      >
                        <option value="">All Status</option>
                        <option value="active">Active</option>
                        <option value="inactive">Inactive</option>
                      </select>
                    </div>
                  </div>

                  <!-- Action Buttons -->
                  <div class="flex gap-2 mb-4">
                    <button
                      @click="showAddSysDictModal = true"
                      class="btn btn-primary btn-sm"
                    >
                      <i data-lucide="plus" class="w-4 h-4"></i>
                      Add Entry
                    </button>
                    <button
                      @click="loadSysDictData()"
                      class="btn btn-outline btn-sm"
                      :class="{ 'loading': sysDictLoading }"
                      :disabled="sysDictLoading"
                    >
                      <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                      Refresh
                    </button>
                  </div>

                  <!-- Sys Dict Table -->
                  <div class="overflow-x-auto">
                    <table class="table table-zebra">
                      <thead>
                        <tr>
                          <th>Category</th>
                          <th>Key</th>
                          <th>Value</th>
                          <th>Status</th>
                          <th>Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        <template
                          x-for="item in filteredSysDictData"
                          :key="`${item.category}-${item.key}`"
                        >
                          <tr>
                            <td x-text="item.category"></td>
                            <td x-text="item.key"></td>
                            <td x-text="item.value"></td>
                            <td>
                              <div
                                class="badge"
                                :class="item.in_used ? 'badge-success' : 'badge-error'"
                              >
                                <span
                                  x-text="item.in_used ? 'Active' : 'Inactive'"
                                ></span>
                              </div>
                            </td>
                            <td>
                              <div class="flex gap-1">
                                <button
                                  @click="editSysDictItem(item)"
                                  class="btn btn-ghost btn-xs"
                                  title="Edit"
                                >
                                  <i data-lucide="edit" class="w-3 h-3"></i>
                                </button>
                                <button
                                  @click="confirmDeleteSysDict(item)"
                                  class="btn btn-ghost btn-xs text-error"
                                  title="Delete"
                                >
                                  <i data-lucide="trash-2" class="w-3 h-3"></i>
                                </button>
                              </div>
                            </td>
                          </tr>
                        </template>
                      </tbody>
                    </table>

                    <!-- Empty State -->
                    <div
                      x-show="sysDictData.length === 0 && !sysDictLoading"
                      class="text-center py-8"
                    >
                      <i
                        data-lucide="database"
                        class="w-12 h-12 mx-auto text-base-content/30 mb-4"
                      ></i>
                      <p class="text-base-content/60">
                        No dictionary entries found
                      </p>
                    </div>

                    <!-- Loading State -->
                    <div x-show="sysDictLoading" class="text-center py-8">
                      <span class="loading loading-spinner loading-lg"></span>
                      <p class="text-base-content/60 mt-4">
                        Loading dictionary data...
                      </p>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Sys Map Section -->
              <div class="card bg-base-100 shadow-xl">
                <div class="card-body">
                  <h2 class="card-title">
                    <i data-lucide="map" class="w-5 h-5" aria-hidden="true"></i>
                    System Mapping (Sys Map)
                  </h2>

                  <!-- Filters -->
                  <div class="flex flex-col md:flex-row gap-4 mb-4">
                    <div class="form-control w-full md:w-1/4">
                      <label class="label">
                        <span class="label-text">Category</span>
                      </label>
                      <select
                        x-model="sysMapFilters.category"
                        class="select select-bordered"
                      >
                        <option value="">All Categories</option>
                        <template
                          x-for="category in sysMapCategories"
                          :key="category"
                        >
                          <option :value="category" x-text="category"></option>
                        </template>
                      </select>
                    </div>
                    <div class="form-control w-full md:w-1/4">
                      <label class="label">
                        <span class="label-text">Left Value</span>
                      </label>
                      <input
                        x-model="sysMapFilters.left"
                        type="text"
                        placeholder="Filter by left value"
                        class="input input-bordered"
                      />
                    </div>
                    <div class="form-control w-full md:w-5/12">
                      <label class="label">
                        <span class="label-text">Right Value</span>
                      </label>
                      <input
                        x-model="sysMapFilters.right"
                        type="text"
                        placeholder="Filter by right value"
                        class="input input-bordered"
                      />
                    </div>
                    <div class="form-control w-full md:w-1/6">
                      <label class="label">
                        <span class="label-text">Status</span>
                      </label>
                      <select
                        x-model="sysMapFilters.status"
                        class="select select-bordered"
                      >
                        <option value="">All Status</option>
                        <option value="active">Active</option>
                        <option value="inactive">Inactive</option>
                      </select>
                    </div>
                  </div>

                  <!-- Action Buttons -->
                  <div class="flex gap-2 mb-4">
                    <button
                      @click="showAddSysMapModal = true"
                      class="btn btn-primary btn-sm"
                    >
                      <i data-lucide="plus" class="w-4 h-4"></i>
                      Add Mapping
                    </button>
                    <button
                      @click="loadSysMapData()"
                      class="btn btn-outline btn-sm"
                      :class="{ 'loading': sysMapLoading }"
                      :disabled="sysMapLoading"
                    >
                      <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                      Refresh
                    </button>
                  </div>

                  <!-- Sys Map Table -->
                  <div class="overflow-x-auto">
                    <table class="table table-zebra">
                      <thead>
                        <tr>
                          <th>Category</th>
                          <th>Left Value</th>
                          <th>Right Value</th>
                          <th>Status</th>
                          <th>Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        <template
                          x-for="item in filteredSysMapData"
                          :key="`${item.category}-${item.left_value}-${item.right_value}`"
                        >
                          <tr>
                            <td x-text="item.category"></td>
                            <td x-text="item.left_value"></td>
                            <td x-text="item.right_value"></td>
                            <td>
                              <div
                                class="badge"
                                :class="item.in_used ? 'badge-success' : 'badge-error'"
                              >
                                <span
                                  x-text="item.in_used ? 'Active' : 'Inactive'"
                                ></span>
                              </div>
                            </td>
                            <td>
                              <div class="flex gap-1">
                                <button
                                  @click="editSysMapItem(item)"
                                  class="btn btn-ghost btn-xs"
                                  title="Edit"
                                >
                                  <i data-lucide="edit" class="w-3 h-3"></i>
                                </button>
                                <button
                                  @click="confirmDeleteSysMap(item)"
                                  class="btn btn-ghost btn-xs text-error"
                                  title="Delete"
                                >
                                  <i data-lucide="trash-2" class="w-3 h-3"></i>
                                </button>
                              </div>
                            </td>
                          </tr>
                        </template>
                      </tbody>
                    </table>

                    <!-- Empty State -->
                    <div
                      x-show="sysMapData.length === 0 && !sysMapLoading"
                      class="text-center py-8"
                    >
                      <i
                        data-lucide="map"
                        class="w-12 h-12 mx-auto text-base-content/30 mb-4"
                      ></i>
                      <p class="text-base-content/60">
                        No mapping entries found
                      </p>
                    </div>

                    <!-- Loading State -->
                    <div x-show="sysMapLoading" class="text-center py-8">
                      <span class="loading loading-spinner loading-lg"></span>
                      <p class="text-base-content/60 mt-4">
                        Loading mapping data...
                      </p>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Metadata Modals -->
              <!-- Add Sys Dict Modal -->
              <template x-if="showAddSysDictModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg">
                      <i data-lucide="plus" class="w-5 h-5 inline mr-2"></i>
                      Add Sys Dict Entry
                    </h3>
                    <form @submit.prevent="saveSysDictEntry()" class="py-4">
                      <div class="form-control">
                        <label class="label" for="dict-category">
                          <span class="label-text">Category</span>
                        </label>
                        <input
                          id="dict-category"
                          x-model="sysDictForm.category"
                          type="text"
                          placeholder="Enter category"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="dict-key">
                          <span class="label-text">Key</span>
                        </label>
                        <input
                          id="dict-key"
                          x-model="sysDictForm.key"
                          type="number"
                          placeholder="Enter key"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="dict-value">
                          <span class="label-text">Value</span>
                        </label>
                        <input
                          id="dict-value"
                          x-model="sysDictForm.value"
                          type="text"
                          placeholder="Enter value"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label cursor-pointer">
                          <span class="label-text">Active</span>
                          <input
                            type="checkbox"
                            x-model="sysDictForm.in_used"
                            class="checkbox checkbox-primary"
                          />
                        </label>
                      </div>
                    </form>
                    <div class="modal-action">
                      <button
                        @click="showAddSysDictModal = false; resetSysDictForm()"
                        class="btn"
                      >
                        Cancel
                      </button>
                      <button
                        @click="confirmSaveSysDictEntry()"
                        class="btn btn-primary"
                      >
                        Add Entry
                      </button>
                    </div>
                  </div>
                </div>
              </template>

              <!-- Add Sys Map Modal -->
              <template x-if="showAddSysMapModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg">
                      <i data-lucide="plus" class="w-5 h-5 inline mr-2"></i>
                      Add Sys Map Entry
                    </h3>
                    <form @submit.prevent="saveSysMapEntry()" class="py-4">
                      <div class="form-control">
                        <label class="label" for="map-category">
                          <span class="label-text">Category</span>
                        </label>
                        <input
                          id="map-category"
                          x-model="sysMapForm.category"
                          type="text"
                          placeholder="Enter category"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="map-left">
                          <span class="label-text">Left Value</span>
                        </label>
                        <input
                          id="map-left"
                          x-model="sysMapForm.left_value"
                          type="text"
                          placeholder="Enter left value"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="map-right">
                          <span class="label-text">Right Value</span>
                        </label>
                        <input
                          id="map-right"
                          x-model="sysMapForm.right_value"
                          type="text"
                          placeholder="Enter right value"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label cursor-pointer">
                          <span class="label-text">Active</span>
                          <input
                            type="checkbox"
                            x-model="sysMapForm.in_used"
                            class="checkbox checkbox-primary"
                          />
                        </label>
                      </div>
                    </form>
                    <div class="modal-action">
                      <button
                        @click="showAddSysMapModal = false; resetSysMapForm()"
                        class="btn"
                      >
                        Cancel
                      </button>
                      <button
                        @click="confirmSaveSysMapEntry()"
                        class="btn btn-primary"
                      >
                        Add Mapping
                      </button>
                    </div>
                  </div>
                </div>
              </template>

              <!-- Edit Sys Dict Modal -->
              <template x-if="showEditSysDictModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg">
                      <i data-lucide="edit" class="w-5 h-5 inline mr-2"></i>
                      Edit Sys Dict Entry
                    </h3>
                    <form @submit.prevent="saveSysDictEntry()" class="py-4">
                      <div class="form-control">
                        <label class="label" for="edit-dict-category">
                          <span class="label-text">Category</span>
                        </label>
                        <input
                          id="edit-dict-category"
                          x-model="sysDictForm.category"
                          type="text"
                          placeholder="Enter category"
                          class="input input-bordered"
                          required
                          readonly
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="edit-dict-key">
                          <span class="label-text">Key</span>
                        </label>
                        <input
                          id="edit-dict-key"
                          x-model="sysDictForm.key"
                          type="number"
                          placeholder="Enter key"
                          class="input input-bordered"
                          required
                          readonly
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="edit-dict-value">
                          <span class="label-text">Value</span>
                        </label>
                        <input
                          id="edit-dict-value"
                          x-model="sysDictForm.value"
                          type="text"
                          placeholder="Enter value"
                          class="input input-bordered"
                          required
                        />
                      </div>
                      <div class="form-control">
                        <label class="label cursor-pointer">
                          <span class="label-text">Active</span>
                          <input
                            type="checkbox"
                            x-model="sysDictForm.in_used"
                            class="checkbox checkbox-primary"
                          />
                        </label>
                      </div>
                    </form>
                    <div class="modal-action">
                      <button @click="cancelEditSysDict()" class="btn">
                        Cancel
                      </button>
                      <button
                        @click="confirmSaveSysDictEntry()"
                        class="btn btn-primary"
                      >
                        Update Entry
                      </button>
                    </div>
                  </div>
                </div>
              </template>

              <!-- Edit Sys Map Modal -->
              <template x-if="showEditSysMapModal">
                <div class="modal modal-open" x-cloak>
                  <div class="modal-box">
                    <h3 class="font-bold text-lg">
                      <i data-lucide="edit" class="w-5 h-5 inline mr-2"></i>
                      Edit Sys Map Entry
                    </h3>
                    <form @submit.prevent="saveSysMapEntry()" class="py-4">
                      <div class="form-control">
                        <label class="label" for="edit-map-category">
                          <span class="label-text">Category</span>
                        </label>
                        <input
                          id="edit-map-category"
                          x-model="sysMapForm.category"
                          type="text"
                          placeholder="Enter category"
                          class="input input-bordered"
                          required
                          readonly
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="edit-map-left">
                          <span class="label-text">Left Value</span>
                        </label>
                        <input
                          id="edit-map-left"
                          x-model="sysMapForm.left_value"
                          type="text"
                          placeholder="Enter left value"
                          class="input input-bordered"
                          required
                          readonly
                        />
                      </div>
                      <div class="form-control">
                        <label class="label" for="edit-map-right">
                          <span class="label-text">Right Value</span>
                        </label>
                        <input
                          id="edit-map-right"
                          x-model="sysMapForm.right_value"
                          type="text"
                          placeholder="Enter right value"
                          class="input input-bordered"
                          required
                          readonly
                        />
                      </div>
                      <div class="form-control">
                        <label class="label cursor-pointer">
                          <span class="label-text">Active</span>
                          <input
                            type="checkbox"
                            x-model="sysMapForm.in_used"
                            class="checkbox checkbox-primary"
                          />
                        </label>
                      </div>
                    </form>
                    <div class="modal-action">
                      <button @click="cancelEditSysMap()" class="btn">
                        Cancel
                      </button>
                      <button
                        @click="confirmSaveSysMapEntry()"
                        class="btn btn-primary"
                      >
                        Update Entry
                      </button>
                    </div>
                  </div>
                </div>
              </template>
            </div>
          </div>
        </div>
      </main>
    </div>

    <!-- JavaScript Application -->
    <script>
      // ===================================================================
      // GLOBAL ERROR HANDLERS
      // ===================================================================

      // Handle unhandled promise rejections
      window.addEventListener('unhandledrejection', function(event) {
        console.warn('ðŸš¨ Unhandled promise rejection:', event.reason);
        // Prevent the default browser behavior of logging to console in a disruptive way
        event.preventDefault();
      });

      // Handle general errors
      window.addEventListener('error', function(event) {
        console.warn('ðŸš¨ Unhandled error:', event.error || event.message);
      });

      // ===================================================================
      // APPLICATION INITIALIZATION SYSTEM
      // ===================================================================

      /**
       * ðŸš€ Application Container
       *
       * Centralized application container that avoids polluting the global namespace.
       * All components are contained within the `app` object.
       */
      const app = (() => {
        // Application configuration
        const APP_CONFIG = {
          TOAST_DURATION: 5000,
          API_TIMEOUT: 10000,
          RETRY_ATTEMPTS: 3,
          THEME_STORAGE_KEY: "dev-admin-theme",
          // Global debug configuration
          // Set DEBUG to true to enable verbose logging for all components including AuthService
          // Errors and warnings will always be shown regardless of this setting
          DEBUG: false,
          ENDPOINTS: {
            CONFIG: "/dev/settings",
            HEALTH: "/"
          }
        };

        const TOAST_TYPES = {
          success: { icon: "check-circle", class: "alert-success" },
          error: { icon: "x-circle", class: "alert-error" },
          warning: { icon: "alert-triangle", class: "alert-warning" },
          info: { icon: "info", class: "alert-info" }
        };

        // Utility functions
        const utils = {
          /**
           * Wraps a promise with a timeout to prevent hanging operations
           * @param {Promise} promise - Promise to wrap
           * @param {number} ms - Timeout in milliseconds
           * @returns {Promise} Promise that resolves or rejects with timeout
           */
          async withTimeout(promise, ms = APP_CONFIG.API_TIMEOUT) {
            const timeout = new Promise((_, reject) =>
              setTimeout(() => reject(new Error("Operation timed out")), ms)
            );
            return Promise.race([promise, timeout]);
          },

          async retry(fn, attempts = APP_CONFIG.RETRY_ATTEMPTS) {
            for (let i = 0; i < attempts; i++) {
              try {
                return await fn();
              } catch (error) {
                if (i === attempts - 1) throw error;
                await new Promise(resolve =>
                  setTimeout(resolve, Math.pow(2, i) * 1000)
                );
              }
            }
          },

          /**
           * Formats a date string for display
           * @param {string} dateString - ISO date string
           * @returns {string} Formatted date string
           */
          formatDate(dateString) {
            if (!dateString) return "Unknown";
            try {
              return new Date(dateString).toLocaleDateString();
            } catch (e) {
              return "Invalid Date";
            }
          },

          getUserInitials(user) {
            if (!user?.email) return "??";
            return user.email
              .split("@")[0]
              .substring(0, 2)
              .toUpperCase();
          },

          /**
           * Gets the display name for a user from available metadata
           * @param {Object} user - User object from Supabase
           * @returns {string} Display name or fallback
           */
          getUserDisplayName(user) {
            if (!user) return "Developer";
            return (
              user.user_metadata?.full_name ||
              user.user_metadata?.name ||
              user.email?.split("@")[0] ||
              "Developer"
            );
          },

          getUserAvatar(user) {
            if (!user) return "https://ui-avatars.com/api/?name=Developer";
            return (
              user.user_metadata?.avatar_url ||
              `https://ui-avatars.com/api/?name=${encodeURIComponent(
                user.email
              )}`
            );
          },

          /**
           * Global debug logging utility
           * @param {string} component - Component name (e.g., "AuthService", "APIClient")
           * @param {...any} args - Arguments to log
           */
          debugLog(component, ...args) {
            if (APP_CONFIG.DEBUG) {
              console.log(`ðŸ” ${component}:`, ...args);
            }
          },

          /**
           * Global important logging utility (always shows regardless of debug mode)
           * @param {string} level - Log level ('log', 'warn', 'error')
           * @param {string} component - Component name
           * @param {...any} args - Arguments to log
           */
          importantLog(level, component, ...args) {
            const prefix =
              level === "error" ? "âŒ" : level === "warn" ? "âš ï¸" : "ðŸ”";
            console[level](`${prefix} ${component}:`, ...args);
          }
        };

        // API Service
        const apiService = {
          // Generated API client instance
          client: null,

          // Initialize the API client (non-async version with limited retries)
          initClient(maxRetries = 50) {
            // Check if script failed to load
            if (window.apiClientLoadFailed) {
              utils.importantLog(
                "error",
                "API",
                "API client script failed to load"
              );
              return;
            }

            if (window.ApiClient) {
              try {
                this.client = new window.ApiClient();

                // ðŸ” SECURE TOKEN PROVIDER: Defer setup until AuthService is available
                // This will be configured later in the initialization process
                utils.debugLog(
                  "API",
                  "API client initialized with secure token provider"
                );
              } catch (error) {
                utils.importantLog(
                  "error",
                  "API",
                  "Failed to initialize API client:",
                  error
                );
              }
            } else if (maxRetries > 0) {
              utils.debugLog(
                "API",
                "API client not loaded yet, will retry later"
              );
              // Retry after a short delay with decreasing retry count
              setTimeout(() => this.initClient(maxRetries - 1), 100);
            } else {
              utils.importantLog(
                "error",
                "API",
                "API client failed to load after maximum retries"
              );
            }
          },

          // Async version that waits for client to be available
          async initClientAsync() {
            return new Promise((resolve, reject) => {
              let attempts = 0;
              const maxAttempts = 100; // Max 5 seconds (100 * 50ms)
              const checkInterval = 50;

              const checkClient = () => {
                attempts++;

                // Check if script failed to load
                if (window.apiClientLoadFailed) {
                  const error = new Error("API client script failed to load");
                  utils.importantLog("error", "API", error.message);
                  reject(error);
                  return;
                }

                if (window.ApiClient) {
                  try {
                    this.client = new window.ApiClient();

                    // ðŸ” SECURE TOKEN PROVIDER: Defer setup until AuthService is available
                    // This will be configured later in the initialization process
                    utils.debugLog(
                      "API client initialized successfully with secure token provider"
                    );
                    resolve();
                  } catch (error) {
                    utils.importantLog(
                      "error",
                      "API",
                      "Failed to initialize API client:",
                      error
                    );
                    reject(error);
                  }
                } else if (attempts >= maxAttempts) {
                  const error = new Error(
                    "API client script failed to load within timeout"
                  );
                  utils.importantLog("error", "API", error.message);
                  reject(error);
                } else {
                  setTimeout(checkClient, checkInterval);
                }
              };

              // Check immediately first
              if (window.ApiClient) {
                checkClient();
              } else {
                setTimeout(checkClient, checkInterval);
              }
            });
          },

          async getConfig() {
            const data = await this.client.getDevSettings();

            if (!data?.data) {
              throw new Error("Invalid configuration response format");
            }

            return data.data;
          },

          /**
           * Fetches page data from backend or returns virtual page data
           * @param {string} pageId - Page identifier
           * @returns {Promise<Object>} Page data object
           */
          async getPage(pageId) {
            // Handle profile page with backend data
            if (pageId === "profile") {
              try {
                const profileData = await this.client.getAuthProfile();
                return {
                  status: "success",
                  message: "Profile Page",
                  data: profileData
                };
              } catch (error) {
                utils.importantLog(
                  "error",
                  "Profile",
                  "Error loading profile data:",
                  error
                );
                return {
                  status: "error",
                  message: "Profile Page",
                  data: {},
                  error: error.message
                };
              }
            }

            if (
              pageId === "user-management" ||
              pageId === "onboarding" ||
              pageId === "metadata"
            ) {
              return {
                status: "success",
                message: `${pageId.charAt(0).toUpperCase() +
                  pageId.slice(1).replace("-", " ")} Page`,
                data: {}
              };
            }

            try {
              if (pageId === "app-state") {
                return await this.client.getDevAppState();
              }
              if (pageId === "request-state") {
                return await this.client.getDevRequestState();
              }
              if (pageId === "sys-health") {
                return await this.client.getHealth();
              }
              if (pageId === "rbac") {
                return await this.client.getDevRbac();
              }

              if (pageId === "profile") {
                return await this.client.getAuthProfile();
              } else if (pageId === "onboarding") {
                return await this.client.getAuthOnboarding();
              } else {
                throw new Error(`Unsupported auth page: ${pageId}`);
              }
            } catch (error) {
              console.warn(
                `Failed to load server data for ${pageId}:`,
                error.message
              );
              return {
                status: "offline",
                message: `${pageId.charAt(0).toUpperCase() +
                  pageId.slice(1).replace("-", " ")} Page (Offline Mode)`,
                data: {},
                error: error.message
              };
            }
          },

          async notifyAuthEvent(event, eventData = {}) {
            utils.debugLog(`Notifying backend about auth event: ${event}`);

            const publicEvents = ["INITIAL_SESSION"];
            const isPublicEvent = publicEvents.includes(event);

            const endpoint = isPublicEvent
              ? `/auth/notification/${event}`
              : `/auth/callback/${event}`;

            const data = {
              event: event,
              timestamp: new Date().toISOString(),
              ...eventData
            };

            if (isPublicEvent) {
              return await this.client.postAuthNotification(event, data);
            } else {
              return await this.client.postAuthCallback(event, data);
            }
          }
        };

        // Services
        const pageNavigationService = {
          STORAGE_KEY: "dev_admin_last_page",

          saveCurrentPage(pageId) {
            try {
              localStorage.setItem(this.STORAGE_KEY, pageId);
            } catch (error) {
              console.warn(
                "Could not save current page to localStorage:",
                error
              );
            }
          },

          getLastVisitedPage() {
            try {
              return localStorage.getItem(this.STORAGE_KEY) || "sys-health";
            } catch (error) {
              console.warn(
                "Could not retrieve last page from localStorage:",
                error
              );
              return "sys-health";
            }
          },

          clearLastVisitedPage() {
            try {
              localStorage.removeItem(this.STORAGE_KEY);
            } catch (error) {
              console.warn(
                "Could not clear last page from localStorage:",
                error
              );
            }
          },

          isValidPage(pageId) {
            const validPages = [
              "onboarding",
              "profile",
              "user-management",
              "rbac",
              "sys-health",
              "app-state",
              "request-state"
            ];
            return validPages.includes(pageId);
          },

          async getDefaultPageForUser(user, isFirstTime = false) {
            // For authenticated users, check onboarding status from backend
            if (user) {
              try {
                const response = await app.apiService.client.getAuthOnboarding();
                if (response.status === "success") {
                  // User has completed onboarding, redirect to sys-health (default for existing users)
                  const lastPage = this.getLastVisitedPage();
                  return this.isValidPage(lastPage) ? lastPage : "sys-health";
                } else if (response.status === "redirect") {
                  // User has completed onboarding, use last visited page or sys-health
                  const lastPage = this.getLastVisitedPage();
                  return this.isValidPage(lastPage) ? lastPage : "sys-health";
                } else {
                  // User needs onboarding
                  return "onboarding";
                }
              } catch (error) {
                console.warn("Could not check onboarding status:", error);
                // Fallback to sys-health for existing users
                const lastPage = this.getLastVisitedPage();
                return this.isValidPage(lastPage) ? lastPage : "sys-health";
              }
            }

            // For first-time or non-authenticated users, go to onboarding
            if (isFirstTime) {
              return "onboarding";
            }

            // Fallback to sys-health instead of dashboard
            const lastPage = this.getLastVisitedPage();
            return this.isValidPage(lastPage) ? lastPage : "sys-health";
          },

          // Utility methods for programmatic navigation
          navigateToPage(pageId) {
            utils.debugLog(
              "Navigation",
              `ðŸ§­ Programmatic navigation to: ${pageId}`
            );

            if (!this.isValidPage(pageId)) {
              utils.importantLog(
                "warn",
                "Navigation",
                `Invalid page ID: ${pageId}. Navigation cancelled.`
              );
              return false;
            }

            // Use the store's selectPage method
            Alpine.store("app").selectPage(pageId);
            return true;
          },

          getCurrentPage() {
            return Alpine.store("app").currentPage;
          },

          // Quick navigation methods
          goToSysHealth() {
            return this.navigateToPage("sys-health");
          },

          goToOnboarding() {
            return this.navigateToPage("onboarding");
          },

          goToProfile() {
            return this.navigateToPage("profile");
          },

          goToRBAC() {
            return this.navigateToPage("rbac");
          },

          goToAppState() {
            return this.navigateToPage("app-state");
          },

          goToRequestState() {
            return this.navigateToPage("request-state");
          },

          goToMetadata() {
            return this.navigateToPage("metadata");
          },

          goToUserManagement() {
            return this.navigateToPage("user-management");
          }
        };

        const configService = {
          async load() {
            return await apiService.getConfig();
          },

          getFallbackConfig() {
            return {
              supabaseUrl: null,
              supabaseKey: null,
              backendUrl: "",
              sentryDsn: "",
              sentryEnvironment: "development",
              sentryEnabled: false
            };
          }
        };

        // Toast service
        const toastService = {
          _iconRefreshTimeout: null,

          show(message, type = "info") {
            const config = TOAST_TYPES[type] || TOAST_TYPES.info;
            const store = Alpine.store("toast");

            store.show = true;
            store.message = message;
            store.class = config.class;
            store.icon = config.icon;

            // Auto-hide
            setTimeout(() => {
              store.show = false;
            }, APP_CONFIG.TOAST_DURATION);

            // Refresh icons
            this.refreshIcons();
          },

          refreshIcons() {
            // Debounce icon refresh to prevent multiple rapid calls
            if (this._iconRefreshTimeout) {
              clearTimeout(this._iconRefreshTimeout);
            }

            this._iconRefreshTimeout = setTimeout(() => {
              requestAnimationFrame(() => {
                try {
                  if (typeof lucide !== "undefined" && lucide.createIcons) {
                    lucide.createIcons();
                  }
                } catch (error) {
                  // Silently handle Lucide icon refresh errors to prevent crashes
                  // This can happen when DOM elements are removed during transitions
                  console.debug(
                    "Lucide icon refresh skipped due to DOM state:",
                    error.message
                  );
                }
              });
            }, 50); // Increased delay to allow DOM stabilization
          },

          cleanup() {
            // Clear any pending icon refresh timeout
            if (this._iconRefreshTimeout) {
              clearTimeout(this._iconRefreshTimeout);
              this._iconRefreshTimeout = null;
            }
          }
        };

        // AuthService class (embedded)
        class AuthService {
          constructor(config = {}) {
            // Initialize configuration with defaults
            this.config = {
              // Supabase configuration
              supabaseUrl: config.supabaseUrl || null,
              supabaseKey: config.supabaseKey || null,

              // Callback functions for different scenarios
              onSuccess: config.onSuccess || this._defaultOnSuccess,
              onError: config.onError || this._defaultOnError,
              onWarning: config.onWarning || this._defaultOnWarning,

              // Event callbacks for auth state changes
              onSignedIn: config.onSignedIn || null,
              onSignedOut: config.onSignedOut || null,
              onTokenRefreshed: config.onTokenRefreshed || null,
              onUserUpdated: config.onUserUpdated || null,
              onPasswordRecovery: config.onPasswordRecovery || null,
              onInitialSession: config.onInitialSession || null,

              // OAuth providers configuration
              oauthProviders: config.oauthProviders || [
                { id: "google", name: "Google", icon: "chrome" },
                { id: "github", name: "GitHub", icon: "github" }
              ],

              // Auto-refresh configuration
              autoRefresh: config.autoRefresh !== false, // Default: true

              // Password policy configuration
              passwordPolicy: {
                minLength: 8,
                requireUppercase: true,
                requireLowercase: true,
                requireNumbers: true,
                requireSpecialChars: false,
                ...config.passwordPolicy
              },

              // Redirect URLs
              redirectUrls: {
                login: config.redirectUrls?.login || window.location.href,
                passwordReset:
                  config.redirectUrls?.passwordReset || window.location.href,
                ...config.redirectUrls
              },

              // Debug mode - use global debug flag if not explicitly provided
              debug:
                config.debug !== undefined ? config.debug : APP_CONFIG.DEBUG
            };

            // Internal state
            this._supabaseClient = null;
            this._currentUser = null;
            this._currentSession = null;
            this._isInitialized = false;
            this._authStateListeners = [];

            // Bind methods to preserve context
            this.init = this.init.bind(this);
            this.handleAuthStateChange = this.handleAuthStateChange.bind(this);
          }

          // ===================================================================
          // INITIALIZATION & CONFIGURATION
          // ===================================================================

          /**
           * Initialize the AuthService with an existing Supabase client
           * @param {Object} supabaseClient - Existing Supabase client instance
           * @returns {Promise<boolean>} True if initialization successful
           */
          async init(supabaseClient = null) {
            if (this._isInitialized) {
              this._log(
                "AuthService already initialized, reusing existing instance"
              );
              return true;
            }

            try {
              this._log("Initializing AuthService with Supabase...");

              // Use provided Supabase client or create a new one
              if (supabaseClient) {
                this._supabaseClient = supabaseClient;
                this._log("âœ… Using existing Supabase client");
              } else {
                // Fallback: create new client if none provided
                if (!this.config.supabaseUrl || !this.config.supabaseKey) {
                  throw new Error(
                    "Supabase URL and key are required for initialization"
                  );
                }
                this._supabaseClient = supabase.createClient(
                  this.config.supabaseUrl,
                  this.config.supabaseKey
                );
                this._logImportant(
                  "warn",
                  "âš ï¸ Created new Supabase client - DUPLICATE INSTANCE"
                );
              }

              // Set up auth state listener
              this._supabaseClient.auth.onAuthStateChange((event, session) => {
                this.handleAuthStateChange(event, session);
              });

              // Check for existing session using secure pattern
              // Note: We can't use getUserInfo() here as it requires _isInitialized to be true
              // So we implement the secure pattern inline during initialization
              try {
                // Step 1: Verify user with .auth.getUser() first for security
                const {
                  data: userData,
                  error: userError
                } = await this._supabaseClient.auth.getUser();

                if (userError) {
                  this._log(
                    "error",
                    "User verification during init failed:",
                    userError.message
                  );
                  // Clean up localStorage on verification failure
                  try {
                    localStorage.removeItem("supabase.auth.token");
                    this._log(
                      "Cleaned up localStorage due to init verification failure"
                    );
                  } catch (cleanupError) {
                    this._logImportant(
                      "error",
                      "Failed to clean localStorage during init:",
                      cleanupError
                    );
                  }
                } else if (userData.user) {
                  // Step 2: If user verification successful, get session for complete info
                  const {
                    data: sessionData,
                    error: sessionError
                  } = await this._supabaseClient.auth.getSession();

                  if (sessionError) {
                    this._logImportant(
                      "error",
                      "Session retrieval during init failed:",
                      sessionError.message
                    );
                    // Still set user even if session fails
                    this._currentUser = userData.user;
                    this._currentSession = null;
                  } else if (sessionData.session) {
                    this._currentSession = sessionData.session;
                    this._currentUser = userData.user;
                    this._log(
                      "Existing session found and verified for user:",
                      userData.user.email
                    );
                  }
                }
              } catch (error) {
                this._logImportant(
                  "error",
                  "Error during secure session check:",
                  error
                );
              }

              this._isInitialized = true;
              this._log("AuthService initialized successfully");

              // Trigger initial session event
              if (this.config.onInitialSession) {
                this.config.onInitialSession(this._currentSession);
              }

              return true;
            } catch (error) {
              this._logImportant(
                "error",
                "AuthService initialization failed:",
                error
              );
              this.config.onError(
                `Initialization failed: ${error.message}`,
                "INIT_ERROR",
                error
              );
              return false;
            }
          }

          /**
           * Update configuration after initialization
           * @param {Object} newConfig - Configuration updates
           */
          updateConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._log("Configuration updated");
          }

          // ===================================================================
          // AUTHENTICATION METHODS
          // ===================================================================

          /**
           * Register a new user with email and password
           * @param {string} email - User email
           * @param {string} password - User password
           * @param {Object} metadata - Additional user metadata
           * @returns {Promise<Object>} Registration result
           */
          async register(email, password, metadata = {}) {
            try {
              this._ensureInitialized();
              this._validateEmail(email);
              this._validatePassword(password);

              this._log("Attempting user registration for:", email);

              const { data, error } = await this._supabaseClient.auth.signUp({
                email,
                password,
                options: {
                  data: metadata,
                  ...(this.config.redirectUrls.login && {
                    emailRedirectTo: this.config.redirectUrls.login
                  })
                }
              });

              if (error) throw error;

              const message = data.user?.email_confirmed_at
                ? "Registration successful! You are now logged in."
                : "Registration successful! Please check your email for verification.";

              this.config.onSuccess(message, "REGISTER_SUCCESS", data);
              this._log("Registration successful for:", email);

              return {
                success: true,
                user: data.user,
                session: data.session,
                needsEmailConfirmation: !data.user?.email_confirmed_at
              };
            } catch (error) {
              this._log("Registration failed:", error);
              const errorMessage = this._getErrorMessage(
                error,
                "Registration failed"
              );
              this.config.onError(errorMessage, "REGISTER_ERROR", error);

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          /**
           * Sign in with email and password
           * @param {string} email - User email
           * @param {string} password - User password
           * @returns {Promise<Object>} Sign in result
           */
          async signInWithEmail(email, password) {
            try {
              this._ensureInitialized();
              this._validateEmail(email);

              this._log("Attempting email sign in for:", email);

              const {
                data,
                error
              } = await this._supabaseClient.auth.signInWithPassword({
                email,
                password
              });

              if (error) throw error;

              this.config.onSuccess(
                "Sign in successful!",
                "SIGNIN_SUCCESS",
                data
              );
              this._log("Email sign in successful for:", email);

              return {
                success: true,
                user: data.user,
                session: data.session
              };
            } catch (error) {
              this._log("Email sign in failed:", error);
              const errorMessage = this._getErrorMessage(
                error,
                "Sign in failed"
              );
              this.config.onError(errorMessage, "SIGNIN_ERROR", error);

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          /**
           * Sign in with OAuth provider
           * @param {string} provider - OAuth provider (google, github, etc.)
           * @param {Object} options - Additional OAuth options
           * @returns {Promise<Object>} OAuth sign in result
           */
          async signInWithOAuth(provider, options = {}) {
            try {
              this._ensureInitialized();

              if (!this._isValidOAuthProvider(provider)) {
                throw new Error(`Invalid OAuth provider: ${provider}`);
              }

              this._log(`Attempting ${provider} OAuth sign in`);

              const {
                data,
                error
              } = await this._supabaseClient.auth.signInWithOAuth({
                provider,
                options: {
                  redirectTo: this.config.redirectUrls.login,
                  ...options
                }
              });

              if (error) throw error;

              // OAuth redirects to provider, so we don't have immediate success feedback
              this._log(`${provider} OAuth initiated successfully`);

              return {
                success: true,
                provider,
                url: data.url
              };
            } catch (error) {
              this._log(`${provider} OAuth failed:`, error);
              const errorMessage = this._getErrorMessage(
                error,
                `${provider} sign in failed`
              );
              this.config.onError(errorMessage, "OAUTH_ERROR", error);

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          /**
           * Sign out the current user
           * @returns {Promise<Object>} Sign out result
           */
          async signOut() {
            try {
              this._ensureInitialized();

              if (!this._currentUser) {
                this.config.onWarning(
                  "No user is currently signed in",
                  "SIGNOUT_WARNING"
                );
                return { success: true, wasSignedIn: false };
              }

              this._log("Attempting user sign out");

              const { error } = await this._supabaseClient.auth.signOut();

              if (error) {
                // Handle specific case where session is already missing
                if (
                  error.message.includes("session missing") ||
                  error.message.includes("Auth session missing")
                ) {
                  this._log(
                    "Session already missing, proceeding with local sign out"
                  );
                  this._currentUser = null;
                  this._currentSession = null;
                  this.config.onSuccess(
                    "Signed out successfully",
                    "SIGNOUT_SUCCESS"
                  );
                  return { success: true, wasSignedIn: true };
                }
                throw error;
              }

              this.config.onSuccess(
                "Signed out successfully",
                "SIGNOUT_SUCCESS"
              );
              this._log("Sign out successful");

              return {
                success: true,
                wasSignedIn: true
              };
            } catch (error) {
              this._log("Sign out failed:", error);
              const errorMessage = this._getErrorMessage(
                error,
                "Sign out failed"
              );
              this.config.onError(errorMessage, "SIGNOUT_ERROR", error);

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          // ===================================================================
          // PASSWORD MANAGEMENT
          // ===================================================================

          /**
           * Change user password (requires current session)
           * @param {string} newPassword - New password
           * @returns {Promise<Object>} Password change result
           */
          async changePassword(newPassword) {
            try {
              this._ensureInitialized();
              this._ensureAuthenticated();
              this._validatePassword(newPassword);

              this._log("Attempting password change for current user");

              const {
                data,
                error
              } = await this._supabaseClient.auth.updateUser({
                password: newPassword
              });

              if (error) throw error;

              this.config.onSuccess(
                "Password changed successfully",
                "PASSWORD_CHANGE_SUCCESS",
                data
              );
              this._log("Password change successful");

              return {
                success: true,
                user: data.user
              };
            } catch (error) {
              this._log("Password change failed:", error);
              let errorMessage = this._getErrorMessage(
                error,
                "Password change failed"
              );

              // Handle specific password change errors
              if (
                error.message.includes(
                  "New password should be different from the old password"
                )
              ) {
                errorMessage =
                  "New password must be different from your current password";
              }

              this.config.onError(errorMessage, "PASSWORD_CHANGE_ERROR", error);

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          /**
           * Initiate password reset via email
           * @param {string} email - User email
           * @returns {Promise<Object>} Password reset initiation result
           */
          async resetPassword(email) {
            try {
              this._ensureInitialized();
              this._validateEmail(email);

              this._log("Initiating password reset for:", email);

              const {
                error
              } = await this._supabaseClient.auth.resetPasswordForEmail(email, {
                redirectTo: this.config.redirectUrls.passwordReset
              });

              if (error) throw error;

              this.config.onSuccess(
                "Password reset email sent successfully",
                "PASSWORD_RESET_SUCCESS"
              );
              this._log("Password reset initiated for:", email);

              return {
                success: true,
                email
              };
            } catch (error) {
              this._log("Password reset failed:", error);
              let errorMessage = this._getErrorMessage(
                error,
                "Password reset failed"
              );

              // Handle specific reset errors
              if (
                error.message.includes("rate limit") ||
                error.message.includes("429")
              ) {
                errorMessage =
                  "Too many reset requests. Please wait before trying again.";
              } else if (error.message.includes("invalid email")) {
                errorMessage = "Invalid email address.";
              }

              this.config.onError(errorMessage, "PASSWORD_RESET_ERROR", error);

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          /**
           * Complete password recovery (during password reset flow)
           * @param {string} newPassword - New password
           * @returns {Promise<Object>} Password recovery result
           */
          async completePasswordRecovery(newPassword) {
            try {
              this._ensureInitialized();
              this._validatePassword(newPassword);

              this._log("Completing password recovery");

              const {
                data,
                error
              } = await this._supabaseClient.auth.updateUser({
                password: newPassword
              });

              if (error) throw error;

              this.config.onSuccess(
                "Password reset completed successfully! You are now logged in.",
                "PASSWORD_RECOVERY_SUCCESS",
                data
              );
              this._log("Password recovery completed successfully");

              return {
                success: true,
                user: data.user
              };
            } catch (error) {
              this._log("Password recovery failed:", error);
              const errorMessage = this._getErrorMessage(
                error,
                "Password recovery failed"
              );
              this.config.onError(
                errorMessage,
                "PASSWORD_RECOVERY_ERROR",
                error
              );

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          // ===================================================================
          // USER MANAGEMENT
          // ===================================================================

          /**
           * Deactivate user account (requires backend support)
           * @param {string} confirmationPassword - User password for confirmation
           * @param {Function} apiDeactivateFunction - Backend API function for deactivation
           * @returns {Promise<Object>} Deactivation result
           */
          async deactivateAccount(confirmationPassword, apiDeactivateFunction) {
            try {
              this._ensureInitialized();
              this._ensureAuthenticated();

              if (!confirmationPassword) {
                throw new Error(
                  "Password confirmation is required to deactivate account"
                );
              }

              if (
                !apiDeactivateFunction ||
                typeof apiDeactivateFunction !== "function"
              ) {
                throw new Error("Backend deactivation function is required");
              }

              this._log("Attempting account deactivation");

              // Call backend deactivation API
              await apiDeactivateFunction({ password: confirmationPassword });

              this.config.onSuccess(
                "Account deactivated successfully",
                "DEACTIVATE_SUCCESS"
              );
              this._log("Account deactivation successful");

              // Sign out after deactivation
              await this.signOut();

              return {
                success: true
              };
            } catch (error) {
              this._log("Account deactivation failed:", error);
              const errorMessage = this._getErrorMessage(
                error,
                "Account deactivation failed"
              );
              this.config.onError(errorMessage, "DEACTIVATE_ERROR", error);

              return {
                success: false,
                error: errorMessage
              };
            }
          }

          // ===================================================================
          // SESSION MANAGEMENT
          // ===================================================================

          /**
           * Get current session
           * @returns {Object|null} Current session
           */
          getCurrentSession() {
            return this._currentSession;
          }

          /**
           * Get current user
           * @returns {Object|null} Current user
           */
          getCurrentUser() {
            return this._currentUser;
          }

          /**
           * Check if user is authenticated
           * @returns {boolean} True if authenticated
           */
          isAuthenticated() {
            return !!(this._currentUser && this._currentSession);
          }

          /**
           * Get user info with secure token verification
           * This method implements the secure pattern recommended by Supabase:
           * 1. First call .auth.getUser() to verify token with Supabase Auth
           * 2. If successful, use .auth.getSession() for subsequent calls for better performance
           * 3. Clean up localStorage on verification failures
           * @param {boolean} forceVerification - Force verification with .auth.getUser() even if session exists
           * @returns {Promise<Object>} User info result with user, session, and verification status
           */
          async getUserInfo(forceVerification = false) {
            try {
              this._ensureInitialized();

              // If we have a cached session and not forcing verification, use it
              if (
                !forceVerification &&
                this._currentSession &&
                this._currentUser
              ) {
                // this._log("Using cached session for getUserInfo");
                return {
                  success: true,
                  user: this._currentUser,
                  session: this._currentSession,
                  verified: false, // Indicates this was from cache, not verified
                  source: "cache"
                };
              }

              this._log("Verifying user info with Supabase Auth");

              // Step 1: Always verify with .auth.getUser() first for security
              const {
                data: userData,
                error: userError
              } = await this._supabaseClient.auth.getUser();

              if (userError) {
                this._log("User verification failed:", userError.message);

                // Clean up localStorage on verification failure
                try {
                  localStorage.removeItem("supabase.auth.token");
                  this._log(
                    "Cleaned up localStorage due to verification failure"
                  );
                } catch (cleanupError) {
                  this._log("Failed to clean localStorage:", cleanupError);
                }

                // Clear internal state
                this._currentUser = null;
                this._currentSession = null;

                return {
                  success: false,
                  error: userError.message,
                  verified: false,
                  source: "verification_failed"
                };
              }

              if (!userData.user) {
                this._log("No user found during verification");

                // Clear internal state
                this._currentUser = null;
                this._currentSession = null;

                return {
                  success: false,
                  error: "No authenticated user found",
                  verified: true,
                  source: "no_user"
                };
              }

              // Step 2: If user verification successful, get session for complete info
              const {
                data: sessionData,
                error: sessionError
              } = await this._supabaseClient.auth.getSession();

              if (sessionError) {
                this._log(
                  "Session retrieval failed after user verification:",
                  sessionError.message
                );

                // Even if session fails, we have verified user, so return user info
                this._currentUser = userData.user;
                this._currentSession = null;

                return {
                  success: true,
                  user: userData.user,
                  session: null,
                  verified: true,
                  source: "user_only",
                  warning: "Session unavailable but user verified"
                };
              }

              // Step 3: Update internal state with verified data
              this._currentUser = userData.user;
              this._currentSession = sessionData.session;

              this._log("User info retrieved and verified successfully");

              return {
                success: true,
                user: userData.user,
                session: sessionData.session,
                verified: true,
                source: "verified"
              };
            } catch (error) {
              this._log("getUserInfo failed with exception:", error);

              // Clean up on any unexpected error
              try {
                localStorage.removeItem("supabase.auth.token");
                this._log("Cleaned up localStorage due to exception");
              } catch (cleanupError) {
                this._log("Failed to clean localStorage:", cleanupError);
              }

              // Clear internal state
              this._currentUser = null;
              this._currentSession = null;

              return {
                success: false,
                error:
                  error.message || "Unknown error during user info retrieval",
                verified: false,
                source: "exception"
              };
            }
          }

          /**
           * Refresh current session
           * @returns {Promise<Object>} Refresh result
           */
          async refreshSession() {
            try {
              this._ensureInitialized();

              this._log("Refreshing session");

              const {
                data,
                error
              } = await this._supabaseClient.auth.refreshSession();

              if (error) throw error;

              this._currentSession = data.session;
              this._currentUser = data.user;

              this._log("Session refreshed successfully");

              return {
                success: true,
                session: data.session,
                user: data.user
              };
            } catch (error) {
              this._log("Session refresh failed:", error);
              return {
                success: false,
                error: error.message
              };
            }
          }

          /**
           * Check authentication status and determine appropriate view/page
           * This method provides a comprehensive authentication check with page routing logic
           * @returns {Promise<Object>} Authentication status and routing information
           */
          async checkAuthenticationStatus() {
            try {
              this._log(
                "Checking authentication status with secure verification"
              );

              // Use getUserInfo for secure authentication check
              const userInfo = await this.getUserInfo(true); // Force verification

              if (!userInfo.success) {
                this._log("Authentication check failed:", userInfo.error);
                return {
                  isAuthenticated: false,
                  shouldShowView: "auth", // Show login page
                  shouldShowPage: null,
                  error: userInfo.error,
                  reason: "authentication_failed"
                };
              }

              if (!userInfo.user) {
                this._log("No authenticated user found");
                return {
                  isAuthenticated: false,
                  shouldShowView: "auth", // Show login page
                  shouldShowPage: null,
                  reason: "no_user"
                };
              }

              // User is authenticated, determine appropriate page
              this._log("User authenticated, determining appropriate page");

              return {
                isAuthenticated: true,
                shouldShowView: "app", // Show app view
                shouldShowPage: "sys-health", // Default page - will be overridden by getDefaultPageForUser
                user: userInfo.user,
                session: userInfo.session,
                verified: userInfo.verified,
                reason: "authenticated"
              };
            } catch (error) {
              this._log(
                "Authentication status check failed with exception:",
                error
              );
              return {
                isAuthenticated: false,
                shouldShowView: "auth", // Show login page on error
                shouldShowPage: null,
                error: error.message,
                reason: "exception"
              };
            }
          }

          // ===================================================================
          // AUTH STATE CHANGE HANDLING
          // ===================================================================

          /**
           * Handle Supabase auth state changes
           * @param {string} event - Auth event type
           * @param {Object} session - Session data
           */
          async handleAuthStateChange(event, session) {
            this._log(`Auth state change: ${event}`);

            try {
              // Update internal state
              this._currentSession = session;
              this._currentUser = session?.user || null;

              // Handle specific events
              switch (event) {
                case "SIGNED_IN":
                  await this._handleSignedIn(session);
                  break;
                case "SIGNED_OUT":
                  await this._handleSignedOut();
                  break;
                case "TOKEN_REFRESHED":
                  await this._handleTokenRefreshed(session);
                  break;
                case "USER_UPDATED":
                  await this._handleUserUpdated(session);
                  break;
                case "PASSWORD_RECOVERY":
                  await this._handlePasswordRecovery();
                  break;
                case "INITIAL_SESSION":
                  await this._handleInitialSession(session);
                  break;
                default:
                  this._log(`Unhandled auth event: ${event}`);
              }

              // Notify all registered listeners
              this._notifyAuthStateListeners(event, session);
            } catch (error) {
              this._log(`Error handling auth event ${event}:`, error);
              this.config.onError(
                `Auth error: ${error.message}`,
                "AUTH_STATE_ERROR",
                error
              );
            }
          }

          /**
           * Add auth state change listener
           * @param {Function} listener - Listener function
           * @returns {Function} Unsubscribe function
           */
          addAuthStateListener(listener) {
            this._authStateListeners.push(listener);
            return () => {
              const index = this._authStateListeners.indexOf(listener);
              if (index > -1) {
                this._authStateListeners.splice(index, 1);
              }
            };
          }

          // ===================================================================
          // UTILITY METHODS
          // ===================================================================

          /**
           * Get available OAuth providers
           * @returns {Array} OAuth providers list
           */
          getOAuthProviders() {
            return this.config.oauthProviders;
          }

          /**
           * Validate password against policy
           * @param {string} password - Password to validate
           * @returns {Object} Validation result
           */
          validatePassword(password) {
            const policy = this.config.passwordPolicy;
            const errors = [];

            if (password.length < policy.minLength) {
              errors.push(
                `Password must be at least ${policy.minLength} characters long`
              );
            }

            if (policy.requireUppercase && !/[A-Z]/.test(password)) {
              errors.push(
                "Password must contain at least one uppercase letter"
              );
            }

            if (policy.requireLowercase && !/[a-z]/.test(password)) {
              errors.push(
                "Password must contain at least one lowercase letter"
              );
            }

            if (policy.requireNumbers && !/\d/.test(password)) {
              errors.push("Password must contain at least one number");
            }

            if (
              policy.requireSpecialChars &&
              !/[!@#$%^&*(),.?":{}|<>]/.test(password)
            ) {
              errors.push(
                "Password must contain at least one special character"
              );
            }

            return {
              isValid: errors.length === 0,
              errors
            };
          }

          /**
           * Validate email format
           * @param {string} email - Email to validate
           * @returns {boolean} True if valid
           */
          validateEmailFormat(email) {
            const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
            return emailRegex.test(email);
          }

          // ===================================================================
          // PRIVATE METHODS
          // ===================================================================

          /**
           * Handle SIGNED_IN event
           * @private
           */
          async _handleSignedIn(session) {
            this._log("User signed in:", session.user.email);

            if (this.config.onSignedIn) {
              await this.config.onSignedIn(session.user, session);
            }
          }

          /**
           * Handle SIGNED_OUT event
           * @private
           */
          async _handleSignedOut() {
            this._log("User signed out");

            // Clear internal state immediately
            this._currentUser = null;
            this._currentSession = null;

            if (this.config.onSignedOut) {
              try {
                await this.config.onSignedOut();
              } catch (error) {
                this._logImportant("warn", "Error in onSignedOut callback:", error);
              }
            }
          }

          /**
           * Handle TOKEN_REFRESHED event
           * @private
           */
          async _handleTokenRefreshed(session) {
            this._log("Token refreshed");

            if (this.config.onTokenRefreshed) {
              await this.config.onTokenRefreshed(session.user, session);
            }
          }

          /**
           * Handle USER_UPDATED event
           * @private
           */
          async _handleUserUpdated(session) {
            this._log("User updated");

            if (this.config.onUserUpdated) {
              await this.config.onUserUpdated(session.user, session);
            }
          }

          /**
           * Handle PASSWORD_RECOVERY event
           * @private
           */
          async _handlePasswordRecovery() {
            this._log("Password recovery initiated");

            if (this.config.onPasswordRecovery) {
              await this.config.onPasswordRecovery();
            }
          }

          /**
           * Handle INITIAL_SESSION event
           * @private
           */
          async _handleInitialSession(session) {
            this._log(
              "Initial session detected:",
              session?.user?.email || "none"
            );

            if (this.config.onInitialSession) {
              await this.config.onInitialSession(session);
            }
          }

          /**
           * Notify all auth state listeners
           * @private
           */
          _notifyAuthStateListeners(event, session) {
            this._authStateListeners.forEach(listener => {
              try {
                listener(event, session);
              } catch (error) {
                this._log("Error in auth state listener:", error);
              }
            });
          }

          /**
           * Ensure AuthService is initialized
           * @private
           */
          _ensureInitialized() {
            if (!this._isInitialized) {
              throw new Error(
                "AuthService must be initialized before use. Call init() first."
              );
            }
          }

          /**
           * Ensure user is authenticated
           * @private
           */
          _ensureAuthenticated() {
            if (!this.isAuthenticated()) {
              throw new Error("User must be authenticated for this operation");
            }
          }

          /**
           * Validate email format
           * @private
           */
          _validateEmail(email) {
            if (!email || !this.validateEmailFormat(email)) {
              throw new Error("Please enter a valid email address");
            }
          }

          /**
           * Validate password
           * @private
           */
          _validatePassword(password) {
            if (!password) {
              throw new Error("Password is required");
            }

            const validation = this.validatePassword(password);
            if (!validation.isValid) {
              throw new Error(validation.errors[0]);
            }
          }

          /**
           * Check if OAuth provider is valid
           * @private
           */
          _isValidOAuthProvider(provider) {
            return this.config.oauthProviders.some(p => p.id === provider);
          }

          /**
           * Get user-friendly error message
           * @private
           */
          _getErrorMessage(error, defaultMessage) {
            if (!error) return defaultMessage;

            // Handle common Supabase error messages
            const message = error.message || error.toString();

            if (message.includes("Invalid login credentials")) {
              return "Invalid email or password. Please check your credentials and try again.";
            }

            if (message.includes("Email not confirmed")) {
              return "Please check your email and click the confirmation link before signing in.";
            }

            if (message.includes("User already registered")) {
              return "An account with this email already exists. Please sign in instead.";
            }

            if (message.includes("rate limit") || message.includes("429")) {
              return "Too many requests. Please wait a moment before trying again.";
            }

            return message || defaultMessage;
          }

          /**
           * Default success callback
           * @private
           */
          _defaultOnSuccess(message, type, data) {
            console.log(`âœ… AuthService Success [${type}]:`, message);
          }

          /**
           * Default error callback
           * @private
           */
          _defaultOnError(message, type, error) {
            console.error(`âŒ AuthService Error [${type}]:`, message, error);
          }

          /**
           * Default warning callback
           * @private
           */
          _defaultOnWarning(message, type) {
            console.warn(`âš ï¸ AuthService Warning [${type}]:`, message);
          }

          /**
           * Log debug messages (only shown when debug mode is enabled)
           * @private
           */
          _log(...args) {
            if (this.config.debug) {
              console.log("ðŸ” AuthService:", ...args);
            }
          }

          /**
           * Log errors and warnings (always shown regardless of debug mode)
           * @private
           */
          _logImportant(level, ...args) {
            const prefix =
              level === "error" ? "âŒ" : level === "warn" ? "âš ï¸" : "ðŸ”";
            console[level](`${prefix} AuthService:`, ...args);
          }
        }

        // Initialize variables
        let authService = null;

        // Global initialization state to prevent duplicate initialization across component instances
        let globalAppInitialized = false;
        let globalAppInitializing = false;

        // ===================================================================
        // COMPONENT FUNCTIONS
        // ===================================================================

        const devAdminApp = function() {
          return {
            // Application initialization state
            initialized: false,
            initializing: false,
            steps: {
              scripts: false,
              alpine: false,
              store: false,
              apiClient: false,
              supabase: false,
              authService: false,
              components: false
            },
            errors: [],

            async init() {
              // Check global state first to prevent duplicate initialization across component instances
              if (globalAppInitialized) {
                utils.debugLog(
                  "ðŸš€ Application already initialized globally, skipping..."
                );
                return true;
              }

              if (globalAppInitializing) {
                utils.debugLog(
                  "ðŸš€ Application initialization already in progress globally..."
                );
                return false;
              }

              utils.debugLog("ðŸš€ Initializing Dev Admin Dashboard...");
              globalAppInitializing = true;
              this.initializing = true;

              try {
                // Step 1: Wait for script dependencies
                await this._initializeScripts();
                this.steps.scripts = true;

                // Step 2: Wait for Alpine.js
                await this._initializeAlpine();
                this.steps.alpine = true;

                // Step 3: Initialize Alpine store
                await this._initializeStore();
                this.steps.store = true;

                // Step 4: Initialize Supabase (needed for API client)
                await this._initializeSupabase();
                this.steps.supabase = true;

                // Step 5: Initialize API client (uses Supabase for secure token provider)
                await this._initializeApiClient();
                this.steps.apiClient = true;

                // Step 6: Initialize AuthService
                await this._initializeAuthService();
                this.steps.authService = true;

                // Step 7: Initialize components
                await this._initializeComponents();
                this.steps.components = true;

                utils.debugLog(
                  "âœ… Dev Admin Dashboard initialization completed successfully"
                );

                // Application is now fully initialized and ready
                this.initialized = true;
                globalAppInitialized = true;

                // Post-initialization tasks
                utils.debugLog(
                  "App",
                  "âœ… Application fully initialized and ready"
                );

                // ðŸ›¡ï¸ Initialize user interaction tracking for OAuth security
                if (typeof initUserInteractionTracking === "function") {
                  initUserInteractionTracking();
                }

                // Refresh icons after initialization
                try {
                  app.toastService.refreshIcons();
                } catch (iconError) {
                  console.warn("âš ï¸ Icon refresh failed:", iconError);
                }

                return true;
              } catch (error) {
                console.error(
                  "âŒ Dev Admin Dashboard initialization failed:",
                  error
                );
                this.errors.push(error);
                this._handleInitializationError(error);
                this.initialized = false; // Reset on failure
                globalAppInitialized = false; // Reset global state on failure
                Alpine.store("app").currentView = "auth";
                return false;
              } finally {
                this.initializing = false;
                globalAppInitializing = false;
              }
            },

            /**
             * Wait for all script dependencies to load
             */
            async _initializeScripts() {
              utils.debugLog("App", "ðŸ“¦ Waiting for script dependencies...");

              const requiredScripts = [
                { name: "API Client", check: () => window.apiClientLoaded },
                { name: "Sentry", check: () => window.sentryLoaded },
                {
                  name: "Supabase",
                  check: () => typeof supabase !== "undefined"
                },
                { name: "Lucide", check: () => typeof lucide !== "undefined" }
                // AuthService is now embedded in the main script
              ];

              const maxWaitTime = 10000; // 10 seconds
              const startTime = Date.now();

              while (Date.now() - startTime < maxWaitTime) {
                const loadedScripts = requiredScripts.filter(script =>
                  script.check()
                );
                const stillLoading = requiredScripts.filter(
                  script => !script.check()
                );

                if (stillLoading.length === 0) {
                  utils.debugLog(
                    "App",
                    "ðŸ“¦ All script dependencies loaded successfully"
                  );
                  return;
                }

                // Log progress
                if (Date.now() - startTime > 2000) {
                  // Log after 2 seconds
                  utils.debugLog(
                    "App",
                    `ðŸ“¦ Waiting for: ${stillLoading
                      .map(s => s.name)
                      .join(", ")}`
                  );
                }

                await new Promise(resolve => setTimeout(resolve, 100));
              }

              throw new Error(
                `Script dependencies failed to load within ${maxWaitTime}ms`
              );
            },

            /**
             * Wait for Alpine.js to be ready
             */
            async _initializeAlpine() {
              utils.debugLog("App", "ðŸ”ï¸ Waiting for Alpine.js...");

              const maxWaitTime = 5000; // 5 seconds
              const startTime = Date.now();

              while (Date.now() - startTime < maxWaitTime) {
                if (typeof Alpine !== "undefined" && Alpine.store) {
                  utils.debugLog("App", "ðŸ”ï¸ Alpine.js ready");
                  return;
                }
                await new Promise(resolve => setTimeout(resolve, 50));
              }

              throw new Error("Alpine.js failed to initialize");
            },

            /**
             * Initialize Alpine store
             */
            async _initializeStore() {
              utils.debugLog("App", "ðŸª Initializing Alpine store...");

              if (!Alpine.store) {
                throw new Error("Alpine store not available");
              }

              // Store is initialized via Alpine's store system
              utils.debugLog("App", "ðŸª Alpine store initialized");
            },

            /**
             * Initialize API client
             */
            async _initializeApiClient() {
              utils.debugLog("App", "ðŸ”Œ Initializing API client...");

              // Initialize the API client with secure token provider
              try {
                await app.apiService.initClientAsync();
                utils.debugLog("App", "ðŸ”Œ API client initialized successfully");
              } catch (error) {
                utils.importantLog("warn", "API", "API client initialization failed, continuing without it:", error);
                // Continue initialization even if API client fails
                // The app can still work in limited functionality mode
              }
            },

            /**
             * Initialize Supabase configuration
             */
            async _initializeSupabase() {
              utils.debugLog("App", "ðŸ—„ï¸ Initializing Supabase...");

              // Get Supabase configuration from settings endpoint
              let settingsResponse;
              try {
                settingsResponse = await fetch("/dev/settings");
                if (!settingsResponse.ok) {
                  throw new Error(
                    `Failed to fetch settings: ${settingsResponse.status}`
                  );
                }
              } catch (fetchError) {
                throw new Error(
                  `Network error fetching settings: ${fetchError.message}`
                );
              }

              let settingsData;
              try {
                settingsData = await settingsResponse.json();
              } catch (jsonError) {
                throw new Error(
                  `Failed to parse settings response: ${jsonError.message}`
                );
              }

              const config = settingsData?.data;

              if (!config?.supabaseUrl || !config?.supabaseKey) {
                throw new Error(
                  "Supabase configuration not available in settings endpoint"
                );
              }

              // Store configuration in Alpine store
              const appStore = Alpine.store("app");
              appStore.supabaseUrl = config.supabaseUrl;
              appStore.supabaseKey = config.supabaseKey;

              // Initialize Supabase client (single instance)
              appStore.supabase = supabase.createClient(
                config.supabaseUrl,
                config.supabaseKey
              );

              utils.debugLog("App", "ðŸ—„ï¸ Supabase initialized successfully");
            },

            /**
             * Initialize AuthService
             */
            async _initializeAuthService() {
              utils.debugLog("App", "ðŸ” Initializing AuthService...");

              const appStore = Alpine.store("app");

              if (!appStore.supabaseUrl || !appStore.supabaseKey) {
                throw new Error(
                  "Supabase configuration required for AuthService"
                );
              }

              // Initialize global AuthService
              authService = new AuthService({
                supabaseUrl: appStore.supabaseUrl,
                supabaseKey: appStore.supabaseKey,
                // debug: uses global APP_CONFIG.DEBUG by default

                // Callback configurations
                onSuccess: (message, type, data) => {
                  app.toastService.show(message, "success");
                  utils.debugLog(
                    "Auth",
                    `âœ… Success [${type}]:`,
                    message,
                    data
                  );
                },

                onError: (message, type, error) => {
                  app.toastService.show(message, "error");
                  utils.importantLog(
                    "error",
                    "Auth",
                    `Error [${type}]:`,
                    message,
                    error
                  );
                },

                onWarning: (message, type) => {
                  app.toastService.show(message, "warning");
                  utils.importantLog(
                    "warn",
                    "Auth",
                    `Warning [${type}]:`,
                    message
                  );
                },

                // Auth state change callbacks
                onSignedIn: async (user, session) => {
                  utils.debugLog("AuthService", "User signed in:", user.email);

                  // Update Alpine store
                  appStore.user = user;
                  appStore.session = session;
                  Alpine.store("auth").user = user;
                  Alpine.store("auth").loading = false;

                  // Navigate to app view immediately for better UX
                  appStore.currentView = "app";

                  // Wait a moment to ensure session is fully established
                  await new Promise(resolve => setTimeout(resolve, 100));

                  // Verify session is available before making API calls using AuthService
                  try {
                    const userInfo = await authService.getUserInfo();
                    if (!userInfo.success || !userInfo.session?.access_token) {
                      console.warn(
                        "Session not fully established yet via AuthService, retrying..."
                      );
                      await new Promise(resolve => setTimeout(resolve, 500));
                    }
                  } catch (error) {
                    console.warn("Error checking session:", error);
                  }

                  // Trigger backend callback
                  try {
                    if (app.apiService.client && typeof app.apiService.client.postAuthCallback === 'function') {
                      const response = await app.apiService.client.postAuthCallback(
                        "SIGNED_IN",
                        {}
                      );
                      if (response.data?.available_roles) {
                        appStore.availableRoles = response.data.available_roles;
                      }
                      utils.debugLog(
                        "Backend",
                        "âœ… SIGNED_IN callback successful"
                      );
                    }
                  } catch (error) {
                    utils.importantLog(
                      "warn",
                      "Backend",
                      "SIGNED_IN callback failed:",
                      error
                    );
                  }

                  // Get default page for user
                  try {
                    const defaultPage = await app.pageNavigationService.getDefaultPageForUser(
                      user,
                      false
                    );
                    appStore.currentPage = defaultPage;
                    utils.debugLog(
                      "Navigation",
                      `âœ… Navigated to default page: ${defaultPage}`
                    );
                  } catch (error) {
                    utils.importantLog(
                      "warn",
                      "Navigation",
                      "Failed to get default page, using fallback:",
                      error
                    );
                    // Fallback to sys-health page for a functional experience
                    appStore.currentPage = "sys-health";
                    utils.debugLog(
                      "Navigation",
                      "âœ… Using fallback page: sys-health"
                    );
                  }

                  // Ensure app view is visible (remove x-cloak if needed)
                  setTimeout(() => {
                    const appView = document.querySelector('[x-show*="app"]');
                    if (appView && appView.hasAttribute("x-cloak")) {
                      appView.removeAttribute("x-cloak");
                      utils.debugLog(
                        "UI",
                        "Removed x-cloak from app view to ensure visibility"
                      );
                    }
                  }, 100);
                },

                onSignedOut: async () => {
                  utils.debugLog("AuthService", "User signed out");

                  // Clear Alpine store
                  appStore.user = null;
                  appStore.session = null;
                  Alpine.store("auth").user = null;
                  Alpine.store("auth").loading = false;

                  // Trigger backend callback with improved error handling
                  // Note: The token provider will use window.pendingSignOutToken if available
                  try {
                    if (app.apiService.client && typeof app.apiService.client.postAuthCallback === 'function') {
                      await app.apiService.client.postAuthCallback(
                        "SIGNED_OUT",
                        {}
                      );
                    }
                  } catch (error) {
                    // Clean up any remaining pending token
                    if (window.pendingSignOutToken) {
                      delete window.pendingSignOutToken;
                    }

                    // Only log as warning for 401/403 errors, not as serious errors
                    if (error.status === 401 || error.status === 403) {
                      utils.debugLog(
                        "Backend",
                        "SIGNED_OUT callback returned 401/403 (expected for signed out user):",
                        error.message
                      );
                    } else {
                      utils.importantLog(
                        "warn",
                        "Backend",
                        "SIGNED_OUT callback failed:",
                        error
                      );
                    }
                  }

                  // Navigate to auth
                  appStore.currentView = "auth";
                  app.pageNavigationService.clearLastVisitedPage();
                },

                onTokenRefreshed: async (user, session) => {
                  utils.debugLog("AuthService", "Token refreshed");
                  appStore.session = session;

                  try {
                    if (app.apiService.client && typeof app.apiService.client.postAuthCallback === 'function') {
                      await app.apiService.client.postAuthCallback(
                        "TOKEN_REFRESHED",
                        {}
                      );
                    }
                  } catch (error) {
                    utils.importantLog(
                      "warn",
                      "Backend",
                      "TOKEN_REFRESHED callback failed:",
                      error
                    );
                  }
                },

                onUserUpdated: async (user, session) => {
                  utils.debugLog("AuthService", "User updated");
                  appStore.user = user;
                  appStore.session = session;

                  try {
                    if (app.apiService.client && typeof app.apiService.client.postAuthCallback === 'function') {
                      await app.apiService.client.postAuthCallback(
                        "USER_UPDATED",
                        {}
                      );
                    }
                  } catch (error) {
                    utils.importantLog(
                      "warn",
                      "Backend",
                      "USER_UPDATED callback failed:",
                      error
                    );
                  }
                },

                onPasswordRecovery: () => {
                  utils.debugLog("AuthService", "Password recovery initiated");
                  appStore.showPasswordRecoveryModal = true;
                },

                onInitialSession: session => {
                  utils.debugLog(
                    "AuthService",
                    "Initial session detected:",
                    session?.user?.email || "none"
                  );

                  if (session) {
                    // User is already authenticated
                    appStore.user = session.user;
                    appStore.session = session;
                    Alpine.store("auth").user = session.user;
                    Alpine.store("auth").loading = false;
                    appStore.currentView = "app";
                  } else {
                    // No active session
                    appStore.user = null;
                    appStore.session = null;
                    Alpine.store("auth").user = null;
                    Alpine.store("auth").loading = false;
                    appStore.currentView = "auth";

                    // Ensure auth view is visible by removing x-cloak if needed
                    setTimeout(() => {
                      const authView = document.querySelector(
                        '[x-show*="auth"]'
                      );
                      if (authView && authView.hasAttribute("x-cloak")) {
                        authView.removeAttribute("x-cloak");
                        utils.debugLog(
                          "Removed x-cloak from auth view to ensure visibility"
                        );
                      }
                    }, 100);
                  }
                },

                // OAuth providers
                oauthProviders: [
                  { id: "google", name: "Google", icon: "chrome" },
                  { id: "github", name: "GitHub", icon: "github" }
                ],

                // Password policy
                passwordPolicy: {
                  minLength: 8,
                  requireUppercase: false,
                  requireLowercase: false,
                  requireNumbers: false,
                  requireSpecialChars: false
                },

                // Redirect URLs
                redirectUrls: {
                  login: `${window.location.origin}/dev/admin`,
                  passwordReset: `${window.location.origin}/dev/admin`
                }
              });

              // Initialize the AuthService with the existing Supabase client
              const success = await authService.init(appStore.supabase);
              if (!success) {
                throw new Error("AuthService initialization failed");
              }

              // Make AuthService globally available for token providers
              window.authService = authService;

              // Now configure the API client token provider
              if (app.apiService.client) {
                app.apiService.client.setTokenProvider(async () => {
                  try {
                    const userInfo = await authService.getUserInfo();

                    if (!userInfo.success) {
                      // Check if we have a pending sign out token for SIGNED_OUT callbacks
                      if (window.pendingSignOutToken) {
                        utils.debugLog(
                          "TokenProvider",
                          "ðŸ” Using pending sign out token for logout callback"
                        );
                        const token = window.pendingSignOutToken;
                        // Clear the token after use to prevent reuse
                        delete window.pendingSignOutToken;
                        return token;
                      }

                      utils.importantLog(
                        "warn",
                        "TokenProvider",
                        "Failed to get user info for token provider:",
                        userInfo.error
                      );
                      return null;
                    }

                    if (!userInfo.session?.access_token) {
                      // Check if we have a pending sign out token for SIGNED_OUT callbacks
                      if (window.pendingSignOutToken) {
                        utils.debugLog(
                          "TokenProvider",
                          "ðŸ” Using pending sign out token for logout callback"
                        );
                        const token = window.pendingSignOutToken;
                        // Clear the token after use to prevent reuse
                        delete window.pendingSignOutToken;
                        return token;
                      }

                      utils.debugLog(
                        "TokenProvider",
                        "No active session available from AuthService"
                      );
                      return null;
                    }

                    utils.debugLog(
                      "TokenProvider",
                      "ðŸ” Secure token retrieved via AuthService.getUserInfo()"
                    );
                    return userInfo.session.access_token;
                  } catch (error) {
                    // Check if we have a pending sign out token for SIGNED_OUT callbacks
                    if (window.pendingSignOutToken) {
                      utils.debugLog(
                        "TokenProvider",
                        "ðŸ” Using pending sign out token for logout callback (error fallback)"
                      );
                      const token = window.pendingSignOutToken;
                      // Clear the token after use to prevent reuse
                      delete window.pendingSignOutToken;
                      return token;
                    }

                    utils.importantLog(
                      "error",
                      "TokenProvider",
                      "Token provider error:",
                      error
                    );
                    return null;
                  }
                });
                utils.debugLog(
                  "TokenProvider",
                  "ðŸ” API client token provider configured"
                );
              }

              utils.debugLog("App", "âœ… AuthService initialized successfully");
            },

            /**
             * Initialize application components
             */
            async _initializeComponents() {
              utils.debugLog(
                "App",
                "ðŸ§© Initializing application components..."
              );

              // Initialize Lucide icons using the debounced refresh method
              app.toastService.refreshIcons();

              // Theme toggle is automatically initialized by Alpine.js x-init directive
              // No manual initialization needed here to prevent duplicates

              utils.debugLog("App", "ðŸ§© Application components initialized");
            },

            /**
             * Handle initialization errors
             */
            _handleInitializationError(error) {
              utils.importantLog(
                "error",
                "App",
                "ðŸš¨ Initialization error:",
                error
              );

              // Update loading message
              const appStore = Alpine.store("app");
              if (appStore) {
                appStore.loadingMessage = `Initialization failed: ${error.message}. Please refresh the page.`;
              }

              // Could add error reporting here
            },

            /**
             * Get initialization status
             */
            getStatus() {
              return {
                initialized: this.initialized,
                initializing: this.initializing,
                steps: { ...this.steps },
                errors: [...this.errors]
              };
            }
          };
        };

        const toastManager = function() {
          return {
            // This component uses the global store
          };
        };

        const authComponent = function() {
          return {
            formData: { email: "", password: "" },
            formErrors: {},
            isSignUp: false,

            get oauthProviders() {
              // Get OAuth providers from AuthService
              const authSvc = Alpine.store("app").getAuthService();
              return (
                authSvc?.getOAuthProviders() || [
                  { id: "google", name: "Google", icon: "chrome" },
                  { id: "github", name: "GitHub", icon: "github" }
                ]
              );
            },

            async signInWithOAuth(provider) {
              // ðŸ›¡ï¸ SECURITY: Prevent automatic OAuth calls
              // Only allow OAuth if it's triggered by a trusted user event
              if (!this._isUserInitiated()) {
                console.warn(
                  `ðŸ›¡ï¸ Blocked automatic OAuth call for ${provider} - not user initiated`
                );
                return;
              }

              const authSvc = Alpine.store("app").getAuthService();
              if (!authSvc) {
                app.toastService.show("AuthService not available", "warning");
                return;
              }

              utils.debugLog(
                `Attempting ${provider} OAuth login via AuthService...`
              );
              Alpine.store("auth").loading = true;

              try {
                // Mark this as a first-time login attempt
                Alpine.store("app").isFirstTimeLogin = true;

                const result = await authSvc.signInWithOAuth(provider);

                if (!result.success) {
                  throw new Error(result.error);
                }

                // OAuth redirects to provider, so success is handled by redirect
              } catch (error) {
                console.error(`${provider} OAuth login failed:`, error);
                // Reset flag on error
                Alpine.store("app").isFirstTimeLogin = false;
              } finally {
                Alpine.store("auth").loading = false;
              }
            },

            /**
             * Check if the current call is initiated by a user interaction
             * This prevents automatic OAuth calls from scripts or other non-user sources
             */
            _isUserInitiated() {
              try {
                // Check if there's a recent user event (click, keydown, etc.)
                const now = Date.now();
                const lastUserEvent = window._lastUserEventTime || 0;
                const timeSinceLastEvent = now - lastUserEvent;
                const lastEventType = window._lastUserEventType || "none";

                // Be more strict: only allow OAuth if there was a click event within the last 500ms
                // This prevents automatic calls triggered by other events like focus, keydown, etc.
                if (
                  timeSinceLastEvent < 500 &&
                  (lastEventType === "click" || lastEventType === "mousedown")
                ) {
                  utils.debugLog(
                    `âœ… OAuth call is user-initiated (${lastEventType} ${timeSinceLastEvent}ms ago)`
                  );
                  return true;
                }

                // Also check if we're in the middle of handling a trusted click event
                if (
                  window._handlingTrustedEvent &&
                  window._currentEventType === "click"
                ) {
                  utils.debugLog(
                    `âœ… OAuth call is within trusted click event handler`
                  );
                  return true;
                }

                console.warn(
                  `ðŸ›¡ï¸ Blocked automatic OAuth call - not user-initiated (last event: ${lastEventType} ${timeSinceLastEvent}ms ago)`
                );
                return false;
              } catch (error) {
                console.warn(`âš ï¸ Could not verify user initiation:`, error);
                // Default to blocking the call if we can't verify (more secure)
                return false;
              }
            },

            async handleEmailSubmit() {
              this.clearErrors();

              if (!this.validateForm()) return;

              const authSvc = Alpine.store("app").getAuthService();
              if (!authSvc) {
                app.toastService.show("AuthService not available", "warning");
                return;
              }

              Alpine.store("auth").loading = true;

              try {
                if (this.isSignUp) {
                  await this.signUp(authSvc);
                } else {
                  await this.signIn(authSvc);
                }
              } finally {
                Alpine.store("auth").loading = false;
              }
            },

            async signIn(authSvc) {
              utils.debugLog(
                "Auth",
                "Attempting email login via AuthService..."
              );

              try {
                // Mark this as a first-time login attempt
                Alpine.store("app").isFirstTimeLogin = true;

                const result = await authSvc.signInWithEmail(
                  this.formData.email,
                  this.formData.password
                );

                if (result.success) {
                  this.clearForm();
                  // Success is handled by AuthService callbacks
                } else {
                  throw new Error(result.error);
                }
              } catch (error) {
                utils.importantLog(
                  "error",
                  "Auth",
                  "Email login failed:",
                  error
                );
                // Reset flag on error - error already shown by AuthService
                Alpine.store("app").isFirstTimeLogin = false;
              }
            },

            async signUp(authSvc) {
              utils.debugLog(
                "Auth",
                "Attempting email signup via AuthService..."
              );

              try {
                const result = await authSvc.register(
                  this.formData.email,
                  this.formData.password
                );

                if (result.success) {
                  this.clearForm();
                  // Success message is handled by AuthService callbacks
                } else {
                  throw new Error(result.error);
                }
              } catch (error) {
                utils.importantLog(
                  "error",
                  "Auth",
                  "Email signup failed:",
                  error
                );
                // Error already shown by AuthService
              }
            },

            validateForm() {
              // Clear previous errors
              this.clearErrors();

              if (!this.formData.email) {
                this.formErrors.email = "Email is required";
                return false;
              }

              if (!this.formData.password) {
                this.formErrors.password = "Password is required";
                return false;
              }

              // Use AuthService email validation
              const authSvc = Alpine.store("app").getAuthService();
              if (
                authSvc &&
                !authSvc.validateEmailFormat(this.formData.email)
              ) {
                this.formErrors.email = "Please enter a valid email address";
                return false;
              }

              // Use AuthService password validation for sign up
              if (this.isSignUp && authSvc) {
                const passwordValidation = authSvc.validatePassword(
                  this.formData.password
                );
                if (!passwordValidation.isValid) {
                  this.formErrors.password = passwordValidation.errors[0];
                  return false;
                }
              }

              return true;
            },

            toggleSignUp() {
              this.isSignUp = !this.isSignUp;
              this.clearErrors();
              app.toastService.refreshIcons();
            },

            clearForm() {
              this.formData = { email: "", password: "" };
              this.clearErrors();
            },

            clearErrors() {
              this.formErrors = {};
            }
          };
        };

        const themeToggle = function() {
          return {
            isDark: false,
            initialized: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;
              this.loadTheme();

              // Refresh icons after initialization
              app.toastService.refreshIcons();
            },

            toggle() {
              this.isDark = !this.isDark;
              this.saveTheme();
              this.applyTheme();

              // Refresh icons after theme change
              app.toastService.refreshIcons();
            },

            loadTheme() {
              try {
                const savedTheme =
                  localStorage.getItem(APP_CONFIG.THEME_STORAGE_KEY) || "light";
                this.isDark = savedTheme === "dark";
                this.applyTheme();
              } catch (error) {
                console.warn("localStorage not available, using default theme");
                this.isDark = false;
                this.applyTheme();
              }
            },

            saveTheme() {
              try {
                const theme = this.isDark ? "dark" : "light";
                localStorage.setItem(APP_CONFIG.THEME_STORAGE_KEY, theme);
              } catch (error) {
                console.warn(
                  "localStorage not available, theme preference not saved"
                );
              }
            },

            applyTheme() {
              const theme = this.isDark ? "dark" : "light";
              document.documentElement.setAttribute("data-theme", theme);

              // Force a repaint
              document.documentElement.style.display = "none";
              document.documentElement.offsetHeight; // Trigger reflow
              document.documentElement.style.display = "";
            }
          };
        };

        const userMenu = function() {
          return {
            menuItems: [
              { id: "sys-health", label: "Sys Health", icon: "heart-pulse" },
              { id: "onboarding", label: "Onboarding", icon: "user-check" },
              { id: "profile", label: "Profile", icon: "user" },
              {
                id: "user-management",
                label: "User Management",
                icon: "users"
              },
              { id: "metadata", label: "Metadata", icon: "database" },
              { id: "rbac", label: "RBAC", icon: "shield-check" },
              { id: "app-state", label: "App State", icon: "settings" },
              { id: "request-state", label: "Request State", icon: "send" }
            ],

            async selectMenuItem(item) {
              try {
                // Use centralized API service for page navigation
                const data = await apiService.getPage(item.id);

                // Update the page
                Alpine.store("app").currentPage = item.id;

                // Save the current page to localStorage for future sessions
                pageNavigationService.saveCurrentPage(item.id);

                // Store page data for components to use, including the message
                Alpine.store("app").pageData = {
                  ...(data.data || {}),
                  message: data.message,
                  status: data.status,
                  error: data.error
                };

                // Show appropriate message based on status
                if (data.status === "offline") {
                  app.toastService.show(
                    `${item.label} loaded in offline mode`,
                    "warning"
                  );
                }
              } catch (error) {
                console.error(`Error loading ${item.id} page:`, error);
                app.toastService.show(
                  `Error loading ${item.label} page`,
                  "error"
                );

                // Fallback to local navigation
                Alpine.store("app").currentPage = item.id;

                // Still save the page even on error
                pageNavigationService.saveCurrentPage(item.id);
                Alpine.store("app").pageData = {
                  message: `${item.label} Page`,
                  status: "error",
                  error: error.message
                };
              }

              this.closeDropdown();
            },

            closeDropdown() {
              // Close dropdown immediately
              document.activeElement.blur();

              // Additional cleanup
              setTimeout(() => {
                const dropdownInputs = document.querySelectorAll(
                  '.dropdown input[type="checkbox"]'
                );
                dropdownInputs.forEach(input => (input.checked = false));
              }, 10);
            },

            async signOut() {
              if (this.isSigningOut) {
                return;
              }

              this.isSigningOut = true;

              try {
                const supabase = Alpine.store("app").supabase;
                if (supabase) {
                  try {
                    // Capture current session before sign out (for backend notification) using AuthService
                    const userInfo = await authService.getUserInfo();
                    if (userInfo.success && userInfo.session?.access_token) {
                      // Store the access token temporarily for the SIGNED_OUT event
                      window.pendingSignOutToken =
                        userInfo.session.access_token;
                    }
                  } catch (sessionError) {
                    // If getting session fails, continue with logout anyway
                    utils.importantLog(
                      "warn",
                      "Auth",
                      "Could not get session for logout:",
                      sessionError
                    );
                  }

                  // This will trigger the auth state change handler which will handle backend notification
                  const { error } = await supabase.auth.signOut();
                  if (error) {
                    // If signOut fails due to missing session, treat as already signed out
                    if (
                      error.message.includes("session missing") ||
                      error.message.includes("Auth session missing")
                    ) {
                      utils.importantLog(
                        "warn",
                        "Auth",
                        "Session already missing, proceeding with local logout"
                      );
                      // Force local logout
                      Alpine.store("app").user = null;
                      Alpine.store("app").currentView = "auth";
                      app.toastService.show("Signed out successfully", "info");
                      return;
                    }
                    throw error;
                  }
                } else {
                  // Fallback if no supabase
                  Alpine.store("app").user = null;
                  Alpine.store("app").currentView = "auth";
                  toastService.show("Signed out successfully", "info");
                }
              } catch (error) {
                console.error("Logout failed:", error);
                // For auth session missing errors, treat as already logged out
                if (
                  error.message.includes("session missing") ||
                  error.message.includes("Auth session missing")
                ) {
                  Alpine.store("app").user = null;
                  Alpine.store("app").currentView = "auth";
                  toastService.show("Signed out successfully", "info");
                } else {
                  toastService.show(`Logout failed: ${error.message}`, "error");
                }
              } finally {
                this.isSigningOut = false;
              }
            },

            isSigningOut: false,

            hasAvatar() {
              const user = Alpine.store("app").user;
              return user?.user_metadata?.avatar_url;
            },

            getAvatarUrl() {
              return app.utils.getUserAvatar(Alpine.store("app").user);
            },

            getInitials() {
              return app.utils.getUserInitials(Alpine.store("app").user);
            }
          };
        };

        const pageManager = function() {
          return {
            isTransitioning: false,
            initialized: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              this.$watch("$store.app.currentPage", () => {
                this.handlePageTransition();
              });
            },

            handlePageTransition() {
              this.isTransitioning = true;

              // Force page visibility update
              this.forcePageUpdate();

              setTimeout(() => {
                this.isTransitioning = false;
                app.toastService.refreshIcons();
              }, 50);
            },

            forcePageUpdate() {
              const currentPage = Alpine.store("app").currentPage;
              // console.log(
              //   `ðŸ”„ Force updating page visibility for: ${currentPage}`
              // );

              // Hide all x-show pages first
              const allPageElements = document.querySelectorAll(
                '[x-show*="currentPage"]'
              );
              allPageElements.forEach(el => {
                el.style.display = "none";
                // Re-add x-cloak to hidden pages to prevent flashing
                if (!el.hasAttribute("x-cloak")) {
                  el.setAttribute("x-cloak", "");
                }
              });

              // Show the current x-show page
              const targetPageElement = document.querySelector(
                `[x-show="$store.app.currentPage === '${currentPage}'"]`
              );
              if (targetPageElement) {
                // Remove x-cloak and show the page
                targetPageElement.removeAttribute("x-cloak");
                targetPageElement.style.display = "block";
                // console.log(`âœ… Made page visible: ${currentPage}`);
                // } else {
                //   console.warn(
                //     `âŒ Could not find page element for: ${currentPage}`
                //   );
              }

              // Clean up all template-rendered content to prevent duplication
              const allTemplateContent = document.querySelectorAll(
                "[data-if-template]"
              );
              allTemplateContent.forEach(element => element.remove());

              // Trigger Alpine.js reactivity refresh without manual template handling
              Alpine.nextTick(() => {
                // Ensure icons are refreshed after DOM updates
                app.toastService.refreshIcons();

                // Double-check page visibility after Alpine.js processes
                setTimeout(() => {
                  const finalCheck = document.querySelector(
                    `[x-show="$store.app.currentPage === '${currentPage}'"]`
                  );
                  if (finalCheck && !finalCheck.offsetParent) {
                    console.warn(
                      `âš ï¸  Page ${currentPage} still not visible after Alpine.js processing`
                    );
                    finalCheck.removeAttribute("x-cloak");
                    finalCheck.style.display = "block";
                  }
                }, 100);
              });
            }
          };
        };

        // Page components
        const profilePage = function() {
          return {
            personalFields: [],
            accountFields: [],
            initialized: false,

            // Password management
            showPasswordChangeModal: false,
            passwordForm: { new: "", confirm: "" },
            recoveryForm: { password: "", confirm: "" },
            passwordRecoveryLoading: false,
            passwordChangeLoading: false,

            // Password reset
            passwordResetLoading: false,

            // Account deactivation
            showDeactivateModal: false,
            deactivateConfirmed: false,
            deactivateLoading: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              this.updateFields();

              // Watch for page data changes
              this.$watch("$store.app.pageData", () => {
                this.updateFields();
              });
            },

            updateFields() {
              const user = Alpine.store("app").user;
              const pageData = Alpine.store("app").pageData;

              // Use backend profile data if available and contains user fields, fallback to user data
              const profileData = pageData && pageData.id ? pageData : user;

              this.personalFields = [
                {
                  id: "fullName",
                  label: "Full Name",
                  value:
                    profileData?.user_metadata?.full_name ||
                    profileData?.user_metadata?.name ||
                    profileData?.username ||
                    "Not provided"
                },
                {
                  id: "email",
                  label: "Email",
                  value: profileData?.email || "Not provided",
                  badge: profileData?.email_confirmed_at
                    ? { type: "success", text: "Verified" }
                    : { type: "warning", text: "Unverified" }
                },
                {
                  id: "username",
                  label: "Username",
                  value: profileData?.username || "Not provided"
                }
              ];

              this.accountFields = [
                {
                  id: "userId",
                  label: "User ID",
                  value: profileData?.id || "Unknown",
                  mono: true
                },
                {
                  id: "joined",
                  label: "Joined",
                  value:
                    app.utils.formatDate(profileData?.created_at) || "Unknown"
                },
                {
                  id: "lastSignIn",
                  label: "Last Sign In",
                  value:
                    app.utils.formatDate(profileData?.last_sign_in_at) ||
                    "Unknown"
                },
                {
                  id: "provider",
                  label: "Authentication Provider",
                  value: profileData?.app_metadata?.provider || "email",
                  icon: "shield-check"
                }
              ];
            },

            getUserDisplayName() {
              return app.utils.getUserDisplayName(Alpine.store("app").user);
            },

            getUserEmail() {
              return Alpine.store("app").user?.email || "";
            },

            getUserAvatarUrl() {
              return app.utils.getUserAvatar(Alpine.store("app").user);
            },

            getUserRoles() {
              const pageData = Alpine.store("app").pageData;
              const user = Alpine.store("app").user;

              // Use backend profile data if available, fallback to user data
              const profileData = pageData || user;

              // Return roles array, default to empty array if not available
              return profileData?.roles || [];
            },

            formatRole(role) {
              if (!role) return "";

              // Return role as-is without case conversion
              return role;
            },

            // Password Management Functions
            async changePassword() {
              if (this.passwordChangeLoading) return;

              // Validate form
              if (!this.passwordForm.new || !this.passwordForm.confirm) {
                toastService.show("New password fields are required", "error");
                return;
              }

              if (this.passwordForm.new !== this.passwordForm.confirm) {
                toastService.show("New passwords do not match", "error");
                return;
              }

              // Use AuthService password validation
              const authSvc = Alpine.store("app").getAuthService();
              if (authSvc) {
                const passwordValidation = authSvc.validatePassword(
                  this.passwordForm.new
                );
                if (!passwordValidation.isValid) {
                  toastService.show(passwordValidation.errors[0], "error");
                  return;
                }
              }

              this.passwordChangeLoading = true;

              try {
                if (!authSvc) {
                  throw new Error("AuthService not available");
                }

                const result = await authSvc.changePassword(
                  this.passwordForm.new
                );

                if (result.success) {
                  // Success message is handled by AuthService
                  // Add a small delay before closing modal to allow DOM to stabilize
                  setTimeout(() => {
                    this.showPasswordChangeModal = false;
                    this.resetPasswordForm();
                  }, 100);
                } else {
                  throw new Error(result.error);
                }
              } catch (error) {
                console.error("Password change failed:", error);
                // Error is already handled by AuthService
              } finally {
                this.passwordChangeLoading = false;
              }
            },

            resetPasswordForm() {
              this.passwordForm = { new: "", confirm: "" };
            },

            resetRecoveryForm() {
              this.recoveryForm = { password: "", confirm: "" };
            },

            async completePasswordRecovery() {
              if (this.passwordRecoveryLoading) return;

              // Validate form
              if (!this.recoveryForm.password || !this.recoveryForm.confirm) {
                toastService.show("Both password fields are required", "error");
                return;
              }

              if (this.recoveryForm.password !== this.recoveryForm.confirm) {
                toastService.show("Passwords do not match", "error");
                return;
              }

              // Use AuthService password validation
              const authSvc = Alpine.store("app").getAuthService();
              if (authSvc) {
                const passwordValidation = authSvc.validatePassword(
                  this.recoveryForm.password
                );
                if (!passwordValidation.isValid) {
                  toastService.show(passwordValidation.errors[0], "error");
                  return;
                }
              }

              this.passwordRecoveryLoading = true;

              try {
                if (!authSvc) {
                  throw new Error("AuthService not available");
                }

                const result = await authSvc.completePasswordRecovery(
                  this.recoveryForm.password
                );

                if (result.success) {
                  // Success message is handled by AuthService
                  // Close modal and reset form
                  Alpine.store("app").showPasswordRecoveryModal = false;
                  this.resetRecoveryForm();
                  // The user should now be fully authenticated
                  // The app should automatically transition to the main view
                } else {
                  throw new Error(result.error);
                }
              } catch (error) {
                console.error("Password recovery failed:", error);
                // Error is already handled by AuthService
              } finally {
                this.passwordRecoveryLoading = false;
              }
            },

            async initiatePasswordReset() {
              if (this.passwordResetLoading) return;

              const userEmail = Alpine.store("app").user?.email;
              if (!userEmail) {
                toastService.show(
                  "Unable to determine user email address",
                  "error"
                );
                return;
              }

              this.passwordResetLoading = true;

              try {
                const authSvc = Alpine.store("app").getAuthService();
                if (!authSvc) {
                  throw new Error("AuthService not available");
                }

                const result = await authSvc.resetPassword(userEmail);

                if (!result.success) {
                  throw new Error(result.error);
                }

                // Success message is handled by AuthService
              } catch (error) {
                console.error("Password reset failed:", error);
                // Error is already handled by AuthService
              } finally {
                this.passwordResetLoading = false;
              }
            },

            // Account Operations Functions
            async deactivateAccount() {
              if (this.deactivateLoading || !this.deactivateConfirmed) return;

              this.deactivateLoading = true;

              try {
                const authSvc = Alpine.store("app").getAuthService();
                if (!authSvc) {
                  throw new Error("AuthService not available");
                }

                // Use AuthService deactivateAccount with backend API function
                const result = await authSvc.deactivateAccount(
                  "", // No password required for this implementation
                  () => apiService.client.postAuthDeactivate()
                );

                if (result.success) {
                  // Success and sign out are handled by AuthService
                  this.showDeactivateModal = false;
                  this.deactivateConfirmed = false;

                  // Reload page after a delay to ensure cleanup
                  setTimeout(() => {
                    window.location.reload();
                  }, 2000);
                } else {
                  throw new Error(result.error);
                }
              } catch (error) {
                console.error("Account deactivation failed:", error);
                // Error is already handled by AuthService if it's an AuthService error
                if (!error.message.includes("AuthService")) {
                  toastService.show(
                    `Account deactivation failed: ${error.message}`,
                    "error"
                  );
                }
              } finally {
                this.deactivateLoading = false;
              }
            }
          };
        };

        const userManagementPage = function() {
          return {
            targetUserId: "",
            userIdError: "",
            userInfo: null,

            // Loading states
            banLoading: false,
            unbanLoading: false,
            adjustRolesLoading: false,
            viewBasicInfoLoading: false,

            // Modals and state
            showAdjustRolesModal: false,
            showBanConfirmModal: false,
            showUnbanConfirmModal: false,
            selectedRoles: [],

            // Validation functions
            validateUserInput() {
              const userInput = this.targetUserId.trim();
              this.userIdError = "";

              if (!userInput) {
                return;
              }

              // Check if input contains @ symbol (email detection)
              const isEmail = userInput.includes("@");

              if (isEmail) {
                // Validate email format
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(userInput)) {
                  this.userIdError = "Please enter a valid email address";
                  return;
                }
              } else {
                // Validate UUID format
                if (userInput.length !== 36) {
                  this.userIdError =
                    "User ID must be exactly 36 characters long";
                  return;
                }

                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!uuidRegex.test(userInput)) {
                  this.userIdError =
                    "Invalid UUID format or email address. Expected: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx";
                  return;
                }
              }

              // Clear error if validation passes
              this.userIdError = "";
            },

            // User management functions
            async banUser() {
              if (this.banLoading || !this.targetUserId.trim()) return;

              // Validate user input format before making API call
              this.validateUserInput();
              if (this.userIdError) {
                toastService.show(this.userIdError, "error");
                return;
              }

              this.showBanConfirmModal = false;
              this.banLoading = true;
              this.userIdError = "";

              try {
                await apiService.client.postAuthUsersBan(this.targetUserId, {
                  reason: "Banned via admin interface"
                });

                toastService.show(
                  `User ${this.targetUserId} has been banned`,
                  "success"
                );
                await this.viewUserBasicInfo(); // Refresh user info
              } catch (error) {
                console.error("Ban user failed:", error);
                this.userIdError = error.message || "Failed to ban user";
                toastService.show(
                  `Failed to ban user: ${error.message}`,
                  "error"
                );
              } finally {
                this.banLoading = false;
              }
            },

            async unbanUser() {
              if (this.unbanLoading || !this.targetUserId.trim()) return;

              // Validate user input format before making API call
              this.validateUserInput();
              if (this.userIdError) {
                toastService.show(this.userIdError, "error");
                return;
              }

              this.showUnbanConfirmModal = false;
              this.unbanLoading = true;
              this.userIdError = "";

              try {
                await apiService.client.postAuthUsersUnban(this.targetUserId);

                toastService.show(
                  `User ${this.targetUserId} has been unbanned`,
                  "success"
                );
                await this.viewUserBasicInfo(); // Refresh user info
              } catch (error) {
                console.error("Unban user failed:", error);
                this.userIdError = error.message || "Failed to unban user";
                toastService.show(
                  `Failed to unban user: ${error.message}`,
                  "error"
                );
              } finally {
                this.unbanLoading = false;
              }
            },

            async adjustRoles() {
              if (this.adjustRolesLoading || !this.targetUserId.trim()) return;

              // Validate user input format before making API call
              this.validateUserInput();
              if (this.userIdError) {
                toastService.show(this.userIdError, "error");
                return;
              }

              // Validate that at least one role is selected
              if (this.selectedRoles.length === 0) {
                toastService.show("Please select at least one role", "error");
                return;
              }

              this.adjustRolesLoading = true;

              try {
                await apiService.client.postAuthUsersRolesAdjust(
                  this.targetUserId,
                  {
                    roles: this.selectedRoles
                  }
                );

                toastService.show(`User roles updated successfully`, "success");
                this.showAdjustRolesModal = false;
                this.selectedRoles = [];
                await this.viewUserBasicInfo(); // Refresh user info
              } catch (error) {
                console.error("Adjust roles failed:", error);
                toastService.show(
                  `Failed to adjust roles: ${error.message}`,
                  "error"
                );
              } finally {
                this.adjustRolesLoading = false;
              }
            },

            async viewUserBasicInfo() {
              if (this.viewBasicInfoLoading || !this.targetUserId.trim())
                return;

              // Validate user input format before making API call
              this.validateUserInput();
              if (this.userIdError) {
                toastService.show(this.userIdError, "error");
                return;
              }

              this.viewBasicInfoLoading = true;
              this.userIdError = "";

              try {
                const data = await apiService.client.getAuthUsersBasic(
                  this.targetUserId
                );

                this.userInfo = {
                  id: data.data?.id || this.targetUserId,
                  email: data.data?.email || "N/A",
                  status: data.data?.status || "unknown",
                  roles: data.data?.roles || []
                };

                toastService.show(
                  "User information loaded successfully",
                  "success"
                );
              } catch (error) {
                console.error("View user basic info failed:", error);
                this.userIdError =
                  error.message || "Failed to load user information";
                this.userInfo = null;
                toastService.show(
                  `Failed to load user information: ${error.message}`,
                  "error"
                );
              } finally {
                this.viewBasicInfoLoading = false;
              }
            },

            // Modal management functions
            openAdjustRolesModal() {
              if (!this.userInfo) {
                toastService.show(
                  "Please view user basic info first",
                  "warning"
                );
                return;
              }

              // Initialize selected roles with current user roles
              this.selectedRoles = [...(this.userInfo.roles || [])];
              this.showAdjustRolesModal = true;
            },

            isRoleSelected(role) {
              return this.selectedRoles.includes(role);
            },

            toggleRole(role) {
              const index = this.selectedRoles.indexOf(role);
              if (index > -1) {
                // Only allow unchecking if more than one role is selected
                if (this.selectedRoles.length > 1) {
                  this.selectedRoles.splice(index, 1);
                } else {
                  toastService.show(
                    "Please select at least one role",
                    "warning"
                  );
                }
              } else {
                this.selectedRoles.push(role);
              }
            },

            // Helper methods
            getAvailableRoles() {
              const availableRoles = Alpine.store("app").availableRoles;
              // Fallback to common roles if no cached roles available
              return availableRoles.length > 0 ? availableRoles : [];
            },

            canShowActionButtons() {
              return this.userInfo !== null;
            },

            shouldShowBanButton() {
              return this.userInfo && this.userInfo.status !== "banned";
            },

            shouldShowUnbanButton() {
              return this.userInfo && this.userInfo.status === "banned";
            }
          };
        };

        const appStatePage = function() {
          return {
            appStateData: null,
            loading: false,
            error: "",
            initialized: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              // Watch for page data changes
              this.$watch("$store.app.pageData", newData => {
                this.updateAppStateData(newData);
              });

              // Initial data update
              this.updateAppStateData(Alpine.store("app").pageData);
            },

            updateAppStateData(pageData) {
              this.error = "";

              if (pageData && pageData.status === "success") {
                // Extract the actual app state data (everything except message and status)
                const { message, status, ...appStateData } = pageData;
                this.appStateData = appStateData;
              } else if (pageData && pageData.status === "http error") {
                this.error =
                  pageData.message || "Failed to load app state data";
                this.appStateData = null;
              } else {
                this.appStateData = null;
              }
            },

            async loadHealthData() {
              if (this.loading) return;

              this.loading = true;
              this.error = "";

              try {
                const data = await apiService.client.getDevAppState();

                // Update the store
                Alpine.store("app").pageData = {
                  message: data.message,
                  status: data.status,
                  ...data.data
                };

                toastService.show(
                  "App state refreshed successfully",
                  "success"
                );
              } catch (error) {
                console.error("Error refreshing app state:", error);
                this.error =
                  error.message || "Failed to refresh app state data";
                toastService.show("Failed to refresh app state", "error");
              } finally {
                this.loading = false;
              }
            },

            getPageTitle() {
              const pageData = Alpine.store("app").pageData;
              return pageData?.message || "Application State";
            },

            getPageDescription() {
              return "Real-time application state and configuration data";
            },

            formatAppStateData() {
              if (!this.appStateData) return "";
              try {
                return JSON.stringify(this.appStateData, null, 2);
              } catch (e) {
                return "Error formatting data";
              }
            },

            formatAppStateDataWithSyntax() {
              if (!this.appStateData) return "";
              try {
                const jsonString = JSON.stringify(this.appStateData, null, 2);
                // Simple syntax highlighting for JSON
                return jsonString
                  .replace(
                    /("[\w_-]+")\s*:/g,
                    '<span class="text-purple-400">$1</span>:'
                  )
                  .replace(
                    /:\s*("[^"]*")/g,
                    ': <span class="text-green-400">$1</span>'
                  )
                  .replace(
                    /:\s*(\d+)/g,
                    ': <span class="text-blue-400">$1</span>'
                  )
                  .replace(
                    /:\s*(true|false)/g,
                    ': <span class="text-orange-400">$1</span>'
                  )
                  .replace(
                    /:\s*(null)/g,
                    ': <span class="text-gray-400">$1</span>'
                  );
              } catch (e) {
                return '<span class="text-red-400">Error formatting data</span>';
              }
            },

            getLineNumbers() {
              if (!this.appStateData) return [];
              try {
                const lines = JSON.stringify(this.appStateData, null, 2).split(
                  "\n"
                );
                return lines.map((_, index) => index + 1);
              } catch (e) {
                return [1];
              }
            },

            formatTimestamp() {
              const now = new Date();
              return now.toLocaleString("en-US", {
                month: "short",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit"
              });
            },

            getDataSize() {
              if (!this.appStateData) return "0 bytes";
              try {
                const jsonString = JSON.stringify(this.appStateData);
                const bytes = new Blob([jsonString]).size;
                if (bytes < 1024) return `${bytes} bytes`;
                if (bytes < 1024 * 1024)
                  return `${(bytes / 1024).toFixed(1)} KB`;
                return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
              } catch (e) {
                return "0 bytes";
              }
            },

            getObjectCount() {
              if (!this.appStateData) return 0;
              try {
                const jsonString = JSON.stringify(this.appStateData);
                const braceCount = (jsonString.match(/\{/g) || []).length;
                const arrayCount = (jsonString.match(/\[/g) || []).length;
                return braceCount + arrayCount;
              } catch (e) {
                return 0;
              }
            },

            async exportAsJSON() {
              if (!this.appStateData) {
                toastService.show("No data to export", "warning");
                return;
              }

              try {
                const jsonString = JSON.stringify(this.appStateData, null, 2);
                const blob = new Blob([jsonString], {
                  type: "application/json"
                });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `app-state-${
                  new Date().toISOString().split("T")[0]
                }.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                toastService.show("File downloaded successfully", "success");
              } catch (error) {
                console.error("Export failed:", error);
                toastService.show("Export failed", "error");
              }
            },

            async copyToClipboard() {
              if (!this.appStateData) {
                toastService.show("No data to copy", "warning");
                return;
              }

              try {
                const jsonString = JSON.stringify(this.appStateData, null, 2);
                await navigator.clipboard.writeText(jsonString);
                toastService.show("Copied to clipboard", "success");
              } catch (error) {
                console.error("Copy failed:", error);
                toastService.show("Copy failed", "error");
              }
            }
          };
        };

        const requestStatePage = function() {
          return {
            requestStateData: null,
            loading: false,
            error: "",
            initialized: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              // Watch for page data changes
              this.$watch("$store.app.pageData", newData => {
                this.updateRequestStateData(newData);
              });

              // Initial data update
              this.updateRequestStateData(Alpine.store("app").pageData);
            },

            updateRequestStateData(pageData) {
              this.error = "";

              if (pageData && pageData.status === "success") {
                // Extract the actual request state data (everything except message and status)
                const { message, status, ...requestStateData } = pageData;
                this.requestStateData = requestStateData;
              } else if (pageData && pageData.status === "http error") {
                this.error =
                  pageData.message || "Failed to load request state data";
                this.requestStateData = null;
              } else {
                this.requestStateData = null;
              }
            },

            async loadHealthData() {
              if (this.loading) return;

              this.loading = true;
              this.error = "";

              try {
                const data = await apiService.client.getDevRequestState();

                // Update the store
                Alpine.store("app").pageData = {
                  message: data.message,
                  status: data.status,
                  ...data.data
                };

                toastService.show(
                  "Request state refreshed successfully",
                  "success"
                );
              } catch (error) {
                console.error("Error refreshing request state:", error);
                this.error =
                  error.message || "Failed to refresh request state data";
                toastService.show("Failed to refresh request state", "error");
              } finally {
                this.loading = false;
              }
            },

            getPageTitle() {
              const pageData = Alpine.store("app").pageData;
              return pageData?.message || "Request State";
            },

            getPageDescription() {
              return "Real-time request state and processing data";
            },

            formatRequestStateData() {
              if (!this.requestStateData) return "";
              try {
                return JSON.stringify(this.requestStateData, null, 2);
              } catch (e) {
                return "Error formatting data";
              }
            },

            formatRequestStateDataWithSyntax() {
              if (!this.requestStateData) return "";
              try {
                const jsonString = JSON.stringify(
                  this.requestStateData,
                  null,
                  2
                );
                // Simple syntax highlighting for JSON
                return jsonString
                  .replace(
                    /("[\w_-]+")\s*:/g,
                    '<span class="text-purple-400">$1</span>:'
                  )
                  .replace(
                    /:\s*("[^"]*")/g,
                    ': <span class="text-green-400">$1</span>'
                  )
                  .replace(
                    /:\s*(\d+)/g,
                    ': <span class="text-blue-400">$1</span>'
                  )
                  .replace(
                    /:\s*(true|false)/g,
                    ': <span class="text-orange-400">$1</span>'
                  )
                  .replace(
                    /:\s*(null)/g,
                    ': <span class="text-gray-400">$1</span>'
                  );
              } catch (e) {
                return '<span class="text-red-400">Error formatting data</span>';
              }
            },

            getLineNumbers() {
              if (!this.requestStateData) return [];
              try {
                const lines = JSON.stringify(
                  this.requestStateData,
                  null,
                  2
                ).split("\n");
                return lines.map((_, index) => index + 1);
              } catch (e) {
                return [1];
              }
            },

            formatTimestamp() {
              const now = new Date();
              return now.toLocaleString("en-US", {
                month: "short",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit"
              });
            },

            getDataSize() {
              if (!this.requestStateData) return "0 bytes";
              try {
                const jsonString = JSON.stringify(this.requestStateData);
                const bytes = new Blob([jsonString]).size;
                if (bytes < 1024) return `${bytes} bytes`;
                if (bytes < 1024 * 1024)
                  return `${(bytes / 1024).toFixed(1)} KB`;
                return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
              } catch (e) {
                return "0 bytes";
              }
            },

            getObjectCount() {
              if (!this.requestStateData) return 0;
              try {
                const jsonString = JSON.stringify(this.requestStateData);
                const braceCount = (jsonString.match(/\{/g) || []).length;
                const arrayCount = (jsonString.match(/\[/g) || []).length;
                return braceCount + arrayCount;
              } catch (e) {
                return 0;
              }
            },

            async exportAsJSON() {
              if (!this.requestStateData) {
                toastService.show("No data to export", "warning");
                return;
              }

              try {
                const jsonString = JSON.stringify(
                  this.requestStateData,
                  null,
                  2
                );
                const blob = new Blob([jsonString], {
                  type: "application/json"
                });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `request-state-${
                  new Date().toISOString().split("T")[0]
                }.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                toastService.show("File downloaded successfully", "success");
              } catch (error) {
                console.error("Export failed:", error);
                toastService.show("Export failed", "error");
              }
            },

            async copyToClipboard() {
              if (!this.requestStateData) {
                toastService.show("No data to copy", "warning");
                return;
              }

              try {
                const jsonString = JSON.stringify(
                  this.requestStateData,
                  null,
                  2
                );
                await navigator.clipboard.writeText(jsonString);
                toastService.show("Copied to clipboard", "success");
              } catch (error) {
                console.error("Copy failed:", error);
                toastService.show("Copy failed", "error");
              }
            }
          };
        };

        const sysHealthPage = function() {
          return {
            loading: false,
            error: null,
            healthData: null,
            lastUpdate: null,
            initialized: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              // Load health data when page becomes active
              this.$watch("$store.app.currentPage", page => {
                if (page === "sys-health") {
                  this.loadHealthData();
                }
              });

              // Initial load if we're already on this page
              if (Alpine.store("app").currentPage === "sys-health") {
                this.loadHealthData();
              }
            },

            async loadHealthData() {
              this.loading = true;
              this.error = null;

              try {
                const response = await fetch("/health");

                if (!response.ok) {
                  throw new Error(
                    `HTTP ${response.status}: ${response.statusText}`
                  );
                }

                const data = await response.json();
                this.healthData = data.data || {};
                this.lastUpdate = new Date();
              } catch (err) {
                console.error("Failed to load health data:", err);
                this.error = err.message || "Failed to load health data";
              } finally {
                this.loading = false;
              }
            },

            getPluginIcon(pluginName) {
              const iconMap = {
                db: "database",
                redis: "cpu",
                sentry: "bug",
                auth: "shield"
              };
              return iconMap[pluginName] || "cog";
            },

            getPluginStatus(plugin) {
              if (!plugin || typeof plugin !== "object") {
                return { status: "unknown", color: "gray" };
              }

              // Check common status indicators
              if (plugin.status === "healthy" || plugin.healthy === true) {
                return { status: "healthy", color: "green" };
              }

              if (
                plugin.status === "error" ||
                plugin.error ||
                plugin.healthy === false
              ) {
                return { status: "error", color: "red" };
              }

              if (plugin.status === "warning" || plugin.warnings) {
                return { status: "warning", color: "yellow" };
              }

              // For plugins with connection info, check if they're connected
              if (plugin.connected === true) {
                return { status: "healthy", color: "green" };
              }

              if (plugin.connected === false) {
                return { status: "error", color: "red" };
              }

              // Default to healthy if we have data
              return { status: "healthy", color: "green" };
            },

            formatPluginData(plugin) {
              if (!plugin || typeof plugin !== "object") {
                return [{ key: "Status", value: "No data available" }];
              }

              const formatted = [];

              // Special handling for database plugin
              if (
                plugin.master_schema !== undefined ||
                plugin.replica_schema !== undefined
              ) {
                // Database plugin - use new format, put "Is Ready" first
                if (plugin.is_ready !== undefined) {
                  formatted.push({
                    key: "Is Ready",
                    value: plugin.is_ready ? "âœ…" : "âŒ"
                  });
                }
                if (plugin.master_schema !== undefined) {
                  formatted.push({
                    key: "Master Schema",
                    value: plugin.master_schema || "N/A"
                  });
                }
                if (plugin.replica_schema !== undefined) {
                  formatted.push({
                    key: "Replica Schema",
                    value: plugin.replica_schema || "N/A"
                  });
                }
                if (plugin.master_response !== undefined) {
                  formatted.push({
                    key: "Master Response",
                    value: plugin.master_response ? "âœ…" : "âŒ"
                  });
                }
                if (plugin.replica_response !== undefined) {
                  formatted.push({
                    key: "Replica Response",
                    value: plugin.replica_response ? "âœ…" : "âŒ"
                  });
                }
                return formatted;
              }

              // Special handling for Sentry plugin - display status as "Is Ready"
              if (
                plugin.status !== undefined &&
                plugin.initialized !== undefined
              ) {
                formatted.push({
                  key: "Is Ready",
                  value: plugin.status ? "âœ…" : "âŒ"
                });
              }
              // Special handling for Auth plugin - display is_ready as "Is Ready"
              else if (
                plugin.is_ready !== undefined &&
                plugin.auth_enabled !== undefined
              ) {
                formatted.push({
                  key: "Is Ready",
                  value: plugin.is_ready ? "âœ…" : "âŒ"
                });
              }
              // Add common status field for other plugins
              else if (plugin.status) {
                formatted.push({ key: "Status", value: plugin.status });
              }

              // Handle is_ready for other plugins (like Redis)
              if (
                plugin.is_ready !== undefined &&
                plugin.auth_enabled === undefined
              ) {
                formatted.push({
                  key: "Is Ready",
                  value: plugin.is_ready ? "âœ…" : "âŒ"
                });
              }

              if (plugin.ping !== undefined) {
                formatted.push({
                  key: "Ping",
                  value: plugin.ping ? "âœ…" : "âŒ"
                });
              }

              // Special handling for auth plugin - highlight JWKS cached keys count
              if (
                plugin.jwks_cache &&
                plugin.jwks_cache.cached_keys_count !== undefined
              ) {
                formatted.push({
                  key: "JWKS Cached Keys",
                  value: plugin.jwks_cache.cached_keys_count.toLocaleString()
                });
              }

              // Special handling for Sentry and Auth plugin boolean fields
              if (
                plugin.initialized !== undefined ||
                plugin.auth_enabled !== undefined
              ) {
                // This is Sentry or Auth plugin, convert boolean fields to emojis
                Object.entries(plugin).forEach(([key, value]) => {
                  if (
                    ![
                      "status",
                      "is_ready",
                      "ping",
                      "healthy",
                      "jwks_cache"
                    ].includes(key)
                  ) {
                    let displayValue = value;

                    // Format different types of values
                    if (typeof value === "boolean") {
                      displayValue = value ? "âœ…" : "âŒ";
                    } else if (typeof value === "number") {
                      displayValue = value.toLocaleString();
                    } else if (value && typeof value === "object") {
                      displayValue = JSON.stringify(value, null, 2);
                    } else if (value === null || value === undefined) {
                      displayValue = "N/A";
                    }

                    formatted.push({
                      key: key
                        .replace(/_/g, " ")
                        .replace(/\b\w/g, l => l.toUpperCase()),
                      value: displayValue
                    });
                  }
                });
              } else {
                // Standard processing for other plugins
                Object.entries(plugin).forEach(([key, value]) => {
                  if (
                    ![
                      "status",
                      "is_ready",
                      "ping",
                      "healthy",
                      "jwks_cache"
                    ].includes(key)
                  ) {
                    let displayValue = value;

                    // Format different types of values
                    if (typeof value === "boolean") {
                      displayValue = value ? "Yes" : "No";
                    } else if (typeof value === "number") {
                      displayValue = value.toLocaleString();
                    } else if (value && typeof value === "object") {
                      displayValue = JSON.stringify(value, null, 2);
                    } else if (value === null || value === undefined) {
                      displayValue = "N/A";
                    }

                    formatted.push({
                      key: key
                        .replace(/_/g, " ")
                        .replace(/\b\w/g, l => l.toUpperCase()),
                      value: displayValue
                    });
                  }
                });
              }

              return formatted.length > 0
                ? formatted
                : [{ key: "Status", value: "Available" }];
            },

            formatLastUpdate() {
              if (!this.lastUpdate) return "Never";

              const now = new Date();
              const diffMs = now - this.lastUpdate;
              const diffSecs = Math.floor(diffMs / 1000);

              if (diffSecs < 60) {
                return `${diffSecs} seconds ago`;
              } else if (diffSecs < 3600) {
                return `${Math.floor(diffSecs / 60)} minutes ago`;
              } else {
                return this.lastUpdate.toLocaleTimeString();
              }
            }
          };
        };

        const onboardingPage = function() {
          return {
            progressSteps: [
              { id: "profile", label: "Profile Setup", progress: 100 },
              { id: "auth", label: "Authentication", progress: 100 },
              {
                id: "sys-health",
                label: "Sys Health Exploration",
                progress: 25
              }
            ],
            initialized: false,
            headlineMessage: "",

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              // Update headline when page data changes
              this.$watch("$store.app.pageData", newData => {
                this.updateHeadlineMessage();
              });

              this.$watch("$store.app.currentPage", page => {
                // Update sys health exploration progress
                const sysHealthStep = this.progressSteps.find(
                  s => s.id === "sys-health"
                );
                if (sysHealthStep) {
                  sysHealthStep.progress = page === "sys-health" ? 100 : 25;
                }

                // Update headline when switching to onboarding page
                if (page === "onboarding") {
                  this.updateHeadlineMessage();
                }
              });

              // Initial headline update
              this.updateHeadlineMessage();
            },

            updateHeadlineMessage() {
              const pageData = Alpine.store("app").pageData;
              if (pageData && pageData.message) {
                this.headlineMessage = pageData.message;
              } else {
                this.headlineMessage = "";
              }
            },

            getHeadlineMessage() {
              return this.headlineMessage || "";
            },

            getUserDisplayName() {
              return app.utils.getUserDisplayName(Alpine.store("app").user);
            }
          };
        };

        const rbacPage = function() {
          return {
            loading: false,
            error: null,
            rbacData: {
              rbac_entries: [],
              cache_stats: {
                total_routes: 0,
                route_cache_size: 0,
                tag_role_cache_size: 0
              }
            },
            filteredRoutes: [],
            searchTerm: "",
            methodFilter: "",
            lastUpdate: null,
            initialized: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              // Load RBAC data when page becomes active
              this.$watch("$store.app.currentPage", page => {
                if (page === "rbac") {
                  this.loadRbacData();
                }
              });

              // Load data if already on RBAC page
              if (Alpine.store("app").currentPage === "rbac") {
                this.loadRbacData();
              }
            },

            async loadRbacData() {
              this.loading = true;
              this.error = null;

              try {
                const response = await apiService.client.getDevRbac();

                if (response.status === "success") {
                  this.rbacData = response.data;
                  this.filteredRoutes = [...this.rbacData.rbac_entries];
                  this.filterRoutes(); // Apply sorting after loading data
                  this.lastUpdate = new Date().toLocaleString();
                  toastService.show("RBAC data loaded successfully", "success");
                } else {
                  throw new Error(
                    response.message || "Failed to load RBAC data"
                  );
                }
              } catch (error) {
                console.error("Error loading RBAC data:", error);
                this.error = error.message;
                toastService.show(
                  `Error loading RBAC data: ${error.message}`,
                  "error"
                );
              } finally {
                this.loading = false;
                app.toastService.refreshIcons();
              }
            },

            filterRoutes() {
              let filtered = [...this.rbacData.rbac_entries];

              // Filter by search term
              if (this.searchTerm) {
                const term = this.searchTerm.toLowerCase();
                filtered = filtered.filter(
                  route =>
                    route.path.toLowerCase().includes(term) ||
                    route.name.toLowerCase().includes(term) ||
                    route.tags.some(tag => tag.toLowerCase().includes(term)) ||
                    route.allowed_roles.some(role =>
                      role.toLowerCase().includes(term)
                    )
                );
              }

              // Filter by method
              if (this.methodFilter) {
                filtered = filtered.filter(
                  route => route.method === this.methodFilter
                );
              }

              // Sort by Path + Method by default
              filtered.sort((a, b) => {
                // First sort by path (case-insensitive)
                const pathComparison = a.path
                  .toLowerCase()
                  .localeCompare(b.path.toLowerCase());
                if (pathComparison !== 0) {
                  return pathComparison;
                }
                // If paths are the same, sort by method
                return a.method.localeCompare(b.method);
              });

              this.filteredRoutes = filtered;
            },

            getAccessLevel(route) {
              // Check if route has 'public' tag
              if (route.tags && route.tags.includes("public")) {
                return "Public";
              }
              // Check if route has no tags
              if (!route.tags || route.tags.length === 0) {
                return "Unknown";
              }
              // All other routes are restricted
              return "Restricted";
            },

            getRoleColor(role, index) {
              // Define a set of distinct colors for different roles
              const colors = [
                "badge-primary", // Blue
                "badge-secondary", // Gray
                "badge-accent", // Purple/Pink
                "badge-info", // Cyan
                "badge-success", // Green
                "badge-warning", // Yellow
                "badge-error", // Red
                "badge-neutral" // Neutral
              ];

              // Use role name hash to consistently assign colors
              let hash = 0;
              for (let i = 0; i < role.length; i++) {
                hash = role.charCodeAt(i) + ((hash << 5) - hash);
              }
              const colorIndex = Math.abs(hash) % colors.length;
              return colors[colorIndex];
            },

            getTagColor(tag) {
              // Define specific colors for common tags
              const tagColors = {
                public: "badge-success",
                auth: "badge-primary",
                admin: "badge-error",
                dev: "badge-warning",
                sys: "badge-info",
                monitoring: "badge-accent",
                protected: "badge-secondary"
              };

              // Return specific color if defined, otherwise use hash-based color
              if (tagColors[tag]) {
                return tagColors[tag];
              }

              // Use tag name hash to consistently assign colors for other tags
              const colors = [
                "badge-primary",
                "badge-secondary",
                "badge-accent",
                "badge-info",
                "badge-neutral"
              ];

              let hash = 0;
              for (let i = 0; i < tag.length; i++) {
                hash = tag.charCodeAt(i) + ((hash << 5) - hash);
              }
              const colorIndex = Math.abs(hash) % colors.length;
              return colors[colorIndex];
            },

            getPageDescription() {
              const total = this.rbacData.cache_stats?.total_routes || 0;
              return `Role-Based Access Control - ${total} routes configured`;
            },

            async exportAsJSON() {
              if (
                !this.rbacData.rbac_entries ||
                this.rbacData.rbac_entries.length === 0
              ) {
                toastService.show("No RBAC data to export", "warning");
                return;
              }

              try {
                const exportData = {
                  exported_at: new Date().toISOString(),
                  cache_stats: this.rbacData.cache_stats,
                  rbac_entries: this.rbacData.rbac_entries
                };

                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], {
                  type: "application/json"
                });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `rbac-data-${
                  new Date().toISOString().split("T")[0]
                }.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                toastService.show("RBAC data exported successfully", "success");
              } catch (error) {
                console.error("Export failed:", error);
                toastService.show("Export failed", "error");
              }
            },

            async copyToClipboard() {
              if (
                !this.rbacData.rbac_entries ||
                this.rbacData.rbac_entries.length === 0
              ) {
                toastService.show("No RBAC data to copy", "warning");
                return;
              }

              try {
                const exportData = {
                  exported_at: new Date().toISOString(),
                  cache_stats: this.rbacData.cache_stats,
                  rbac_entries: this.rbacData.rbac_entries
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                await navigator.clipboard.writeText(jsonString);
                toastService.show("Copied to clipboard", "success");
              } catch (error) {
                console.error("Copy failed:", error);
                toastService.show("Copy failed", "error");
              }
            }
          };
        };

        const metadataPage = function() {
          return {
            // Sys Dict data and state
            sysDictData: [],
            sysDictCategories: [],
            sysDictFilters: {
              category: "",
              key: "",
              value: "",
              status: ""
            },
            sysDictLoading: false,

            // Sys Map data and state
            sysMapData: [],
            sysMapCategories: [],
            sysMapFilters: {
              category: "",
              left: "",
              right: "",
              status: ""
            },
            sysMapLoading: false,

            // Modal states
            showAddSysDictModal: false,
            showAddSysMapModal: false,
            showEditSysDictModal: false,
            showEditSysMapModal: false,

            // Form data
            sysDictForm: {
              category: "",
              key: "",
              value: "",
              in_used: true
            },
            sysMapForm: {
              category: "",
              left_value: "",
              right_value: "",
              in_used: true
            },

            // Edit state
            editingSysDictItem: null,
            editingSysMapItem: null,

            initialized: false,

            init() {
              if (this.initialized) {
                return;
              }
              this.initialized = true;

              // Load data when page becomes active
              this.$watch("$store.app.currentPage", page => {
                if (page === "metadata") {
                  this.loadSysDictData();
                  this.loadSysMapData();
                }
              });

              // Initial load if we're already on this page
              if (Alpine.store("app").currentPage === "metadata") {
                this.loadSysDictData();
                this.loadSysMapData();
              }
            },

            async loadSysDictData() {
              this.sysDictLoading = true;
              try {
                // Load all data without filters (filtering is done client-side)
                const result = await apiService.client.postDevSysDictShow({
                  category: null,
                  key: null,
                  value: null,
                  in_used_only: false
                });

                if (result.status === "success") {
                  this.sysDictData = result.data.items || [];
                  // Extract unique categories for dropdown
                  this.sysDictCategories = [
                    ...new Set(this.sysDictData.map(item => item.category))
                  ];
                  toastService.show(
                    result.message || "Sys Dict data loaded",
                    "success"
                  );
                } else {
                  throw new Error(
                    result.message || "Failed to load sys dict data"
                  );
                }
              } catch (error) {
                console.error("Error loading sys dict data:", error);
                toastService.show("Failed to load sys dict data", "error");
                this.sysDictData = [];
              } finally {
                this.sysDictLoading = false;
              }
            },

            async loadSysMapData() {
              this.sysMapLoading = true;
              try {
                // Load all data without filters (filtering is done client-side)
                const result = await apiService.client.postDevSysMapShow({
                  category: null,
                  left_value: null,
                  right_value: null,
                  in_used_only: false
                });

                if (result.status === "success") {
                  this.sysMapData = result.data.items || [];
                  // Extract unique categories for dropdown
                  this.sysMapCategories = [
                    ...new Set(this.sysMapData.map(item => item.category))
                  ];
                  toastService.show(
                    result.message || "Sys Map data loaded",
                    "success"
                  );
                } else {
                  throw new Error(
                    result.message || "Failed to load sys map data"
                  );
                }
              } catch (error) {
                console.error("Error loading sys map data:", error);
                toastService.show("Failed to load sys map data", "error");
                this.sysMapData = [];
              } finally {
                this.sysMapLoading = false;
              }
            },

            editSysDictItem(item) {
              this.editingSysDictItem = item;
              this.sysDictForm = {
                category: item.category,
                key: item.key,
                value: item.value,
                in_used: item.in_used
              };
              this.showEditSysDictModal = true;
            },

            editSysMapItem(item) {
              this.editingSysMapItem = item;
              this.sysMapForm = {
                category: item.category,
                left_value: item.left_value,
                right_value: item.right_value,
                in_used: item.in_used
              };
              this.showEditSysMapModal = true;
            },

            async deleteSysDictItem(item) {
              try {
                // Hard delete from database
                const result = await apiService.client.deleteDevSysDict({
                  category: item.category,
                  key: item.key,
                  value: item.value
                });

                if (result.status === "success") {
                  toastService.show(
                    "Sys Dict entry permanently deleted",
                    "success"
                  );
                  await this.loadSysDictData();
                } else {
                  throw new Error(
                    result.message || "Failed to delete sys dict entry"
                  );
                }
              } catch (error) {
                console.error("Error deleting sys dict entry:", error);
                toastService.show("Failed to delete sys dict entry", "error");
              }
            },

            async softDeleteSysDictItem(item) {
              try {
                // Soft delete by setting in_used to false
                const requestData = {
                  category: item.category,
                  items: this.sysDictData
                    .filter(i => i.category === item.category)
                    .map(i => ({
                      category: i.category,
                      key: i.key,
                      value: i.value,
                      in_used:
                        i.category === item.category && i.key === item.key
                          ? false
                          : i.in_used
                    }))
                };

                const result = await apiService.client.postDevSysDictAdjust(
                  requestData
                );

                if (result.status === "success") {
                  toastService.show("Sys Dict entry deactivated", "success");
                  await this.loadSysDictData();
                } else {
                  throw new Error(
                    result.message || "Failed to deactivate sys dict entry"
                  );
                }
              } catch (error) {
                console.error("Error deactivating sys dict entry:", error);
                toastService.show(
                  "Failed to deactivate sys dict entry",
                  "error"
                );
              }
            },

            async deleteSysMapItem(item) {
              try {
                // Hard delete from database
                const result = await apiService.client.deleteDevSysMap({
                  category: item.category,
                  left_value: item.left_value,
                  right_value: item.right_value
                });

                if (result.status === "success") {
                  toastService.show(
                    "Sys Map entry permanently deleted",
                    "success"
                  );
                  await this.loadSysMapData();
                } else {
                  throw new Error(
                    result.message || "Failed to delete sys map entry"
                  );
                }
              } catch (error) {
                console.error("Error deleting sys map entry:", error);
                toastService.show("Failed to delete sys map entry", "error");
              }
            },

            async softDeleteSysMapItem(item) {
              try {
                // Soft delete by setting in_used to false
                const requestData = {
                  category: item.category,
                  items: this.sysMapData
                    .filter(i => i.category === item.category)
                    .map(i => ({
                      category: i.category,
                      left_value: i.left_value,
                      right_value: i.right_value,
                      in_used:
                        i.category === item.category &&
                        i.left_value === item.left_value &&
                        i.right_value === item.right_value
                          ? false
                          : i.in_used
                    }))
                };

                const result = await apiService.client.postDevSysMapAdjust(
                  requestData
                );

                if (result.status === "success") {
                  toastService.show("Sys Map entry deactivated", "success");
                  await this.loadSysMapData();
                } else {
                  throw new Error(
                    result.message || "Failed to deactivate sys entry"
                  );
                }
              } catch (error) {
                console.error("Error deactivating sys map entry:", error);
                toastService.show(
                  "Failed to deactivate sys map entry",
                  "error"
                );
              }
            },

            async saveSysDictEntry() {
              try {
                // Validate form
                if (
                  !this.sysDictForm.category ||
                  !this.sysDictForm.key ||
                  !this.sysDictForm.value
                ) {
                  toastService.show(
                    "Please fill in all required fields",
                    "warning"
                  );
                  return;
                }

                // Get all items for this category and add/update the new one
                const categoryItems = this.sysDictData.filter(
                  item => item.category === this.sysDictForm.category
                );

                // Check if key already exists (for add mode)
                if (
                  !this.editingSysDictItem &&
                  categoryItems.some(
                    item => item.key === parseInt(this.sysDictForm.key)
                  )
                ) {
                  toastService.show(
                    "Key already exists in this category",
                    "warning"
                  );
                  return;
                }

                // Create the items array with the new/updated item
                const items = categoryItems.map(item => ({
                  category: item.category,
                  key: item.key,
                  value:
                    item.key === parseInt(this.sysDictForm.key)
                      ? this.sysDictForm.value
                      : item.value,
                  in_used:
                    item.key === parseInt(this.sysDictForm.key)
                      ? this.sysDictForm.in_used
                      : item.in_used
                }));

                // Add new item if not editing
                if (!this.editingSysDictItem) {
                  items.push({
                    category: this.sysDictForm.category,
                    key: parseInt(this.sysDictForm.key),
                    value: this.sysDictForm.value,
                    in_used: this.sysDictForm.in_used
                  });
                }

                const requestData = {
                  category: this.sysDictForm.category,
                  items: items
                };

                const result = await apiService.client.postDevSysDictAdjust(
                  requestData
                );
                if (result.status === "success") {
                  toastService.show(
                    this.editingSysDictItem
                      ? "Sys Dict entry updated successfully"
                      : "Sys Dict entry added successfully",
                    "success"
                  );
                  this.showAddSysDictModal = false;
                  this.showEditSysDictModal = false;
                  this.resetSysDictForm();
                  await this.loadSysDictData();
                } else {
                  throw new Error(
                    result.message || "Failed to save sys dict entry"
                  );
                }
              } catch (error) {
                console.error("Error saving sys dict entry:", error);
                toastService.show("Failed to save sys dict entry", "error");
              }
            },

            async saveSysMapEntry() {
              try {
                // Validate form
                if (
                  !this.sysMapForm.category ||
                  !this.sysMapForm.left_value ||
                  !this.sysMapForm.right_value
                ) {
                  toastService.show(
                    "Please fill in all required fields",
                    "warning"
                  );
                  return;
                }

                // Get all items for this category and add/update the new one
                const categoryItems = this.sysMapData.filter(
                  item => item.category === this.sysMapForm.category
                );

                // Check if mapping already exists (for add mode)
                if (
                  !this.editingSysMapItem &&
                  categoryItems.some(
                    item =>
                      item.left_value === this.sysMapForm.left_value &&
                      item.right_value === this.sysMapForm.right_value
                  )
                ) {
                  toastService.show(
                    "Mapping already exists in this category",
                    "warning"
                  );
                  return;
                }

                // Create the items array with the new/updated item
                const items = categoryItems.map(item => ({
                  category: item.category,
                  left_value: item.left_value,
                  right_value: item.right_value,
                  in_used:
                    item.left_value === this.sysMapForm.left_value &&
                    item.right_value === this.sysMapForm.right_value
                      ? this.sysMapForm.in_used
                      : item.in_used
                }));

                // Add new item if not editing
                if (!this.editingSysMapItem) {
                  items.push({
                    category: this.sysMapForm.category,
                    left_value: this.sysMapForm.left_value,
                    right_value: this.sysMapForm.right_value,
                    in_used: this.sysMapForm.in_used
                  });
                }

                const requestData = {
                  category: this.sysMapForm.category,
                  items: items
                };

                const result = await apiService.client.postDevSysMapAdjust(
                  requestData
                );
                if (result.status === "success") {
                  toastService.show(
                    this.editingSysMapItem
                      ? "Sys Map entry updated successfully"
                      : "Sys Map entry added successfully",
                    "success"
                  );
                  this.showAddSysMapModal = false;
                  this.showEditSysMapModal = false;
                  this.resetSysMapForm();
                  await this.loadSysMapData();
                } else {
                  throw new Error(
                    result.message || "Failed to save sys map entry"
                  );
                }
              } catch (error) {
                console.error("Error saving sys map entry:", error);
                toastService.show("Failed to save sys map entry", "error");
              }
            },

            resetSysDictForm() {
              this.sysDictForm = {
                category: "",
                key: "",
                value: "",
                in_used: true
              };
              this.editingSysDictItem = null;
            },

            resetSysMapForm() {
              this.sysMapForm = {
                category: "",
                left_value: "",
                right_value: "",
                in_used: true
              };
              this.editingSysMapItem = null;
            },

            // Enhanced confirmation functions
            async confirmDeleteSysDict(item) {
              const result = await this.showConfirmDialog(
                "Delete Sys Dict Entry",
                `Are you sure you want to delete this entry?\n\nCategory: ${item.category}\nKey: ${item.key}\nValue: ${item.value}\n\nâš ï¸ WARNING: This will PERMANENTLY DELETE the entry from the database and cannot be undone!`,
                "Delete",
                "btn-error"
              );

              if (result) {
                await this.deleteSysDictItem(item);
              }
            },

            async confirmDeleteSysMap(item) {
              const result = await this.showConfirmDialog(
                "Delete Sys Map Entry",
                `Are you sure you want to delete this mapping?\n\nCategory: ${item.category}\nMapping: ${item.left_value} â†’ ${item.right_value}\n\nâš ï¸ WARNING: This will PERMANENTLY DELETE the entry from the database and cannot be undone!`,
                "Delete",
                "btn-error"
              );

              if (result) {
                await this.deleteSysMapItem(item);
              }
            },

            async confirmSaveSysDictEntry() {
              const action = this.editingSysDictItem ? "update" : "create";
              const result = await this.showConfirmDialog(
                `${action === "update" ? "Update" : "Create"} Sys Dict Entry`,
                `Are you sure you want to ${action} this entry?\n\nCategory: ${
                  this.sysDictForm.category
                }\nKey: ${this.sysDictForm.key}\nValue: ${
                  this.sysDictForm.value
                }\nStatus: ${this.sysDictForm.in_used ? "Active" : "Inactive"}`,
                action === "update" ? "Update" : "Create",
                "btn-primary"
              );

              if (result) {
                await this.saveSysDictEntry();
              }
            },

            async confirmSaveSysMapEntry() {
              const action = this.editingSysMapItem ? "update" : "create";
              const result = await this.showConfirmDialog(
                `${action === "update" ? "Update" : "Create"} Sys Map Entry`,
                `Are you sure you want to ${action} this mapping?\n\nCategory: ${
                  this.sysMapForm.category
                }\nMapping: ${this.sysMapForm.left_value} â†’ ${
                  this.sysMapForm.right_value
                }\nStatus: ${this.sysMapForm.in_used ? "Active" : "Inactive"}`,
                action === "update" ? "Update" : "Create",
                "btn-primary"
              );

              if (result) {
                await this.saveSysMapEntry();
              }
            },

            cancelEditSysDict() {
              this.showEditSysDictModal = false;
              this.resetSysDictForm();
            },

            cancelEditSysMap() {
              this.showEditSysMapModal = false;
              this.resetSysMapForm();
            },

            // Enhanced confirmation dialog
            showConfirmDialog(
              title,
              message,
              confirmText = "Confirm",
              confirmClass = "btn-primary"
            ) {
              return new Promise(resolve => {
                // Create modal HTML
                const modalHtml = `
                  <div class="modal modal-open" id="confirmModal">
                    <div class="modal-box">
                      <h3 class="font-bold text-lg mb-4">${title}</h3>
                      <div class="py-4">
                        <p class="whitespace-pre-line">${message}</p>
                      </div>
                      <div class="modal-action">
                        <button class="btn" onclick="closeConfirmModal(false)">Cancel</button>
                        <button class="btn ${confirmClass}" onclick="closeConfirmModal(true)">${confirmText}</button>
                      </div>
                    </div>
                  </div>
                `;

                // Add modal to DOM
                const modalContainer = document.createElement("div");
                modalContainer.innerHTML = modalHtml;
                document.body.appendChild(modalContainer);

                // Add global close function
                window.closeConfirmModal = result => {
                  document.body.removeChild(modalContainer);
                  delete window.closeConfirmModal;
                  resolve(result);
                };
              });
            },

            // Computed properties for filtered data
            get filteredSysDictData() {
              return this.sysDictData.filter(item => {
                // Category filter
                if (
                  this.sysDictFilters.category &&
                  item.category !== this.sysDictFilters.category
                ) {
                  return false;
                }

                // Key filter
                if (
                  this.sysDictFilters.key &&
                  item.key.toString() !== this.sysDictFilters.key.toString()
                ) {
                  return false;
                }

                // Value filter
                if (
                  this.sysDictFilters.value &&
                  !item.value
                    .toLowerCase()
                    .includes(this.sysDictFilters.value.toLowerCase())
                ) {
                  return false;
                }

                // Status filter
                if (this.sysDictFilters.status) {
                  const isActive = item.in_used;
                  if (this.sysDictFilters.status === "active" && !isActive) {
                    return false;
                  }
                  if (this.sysDictFilters.status === "inactive" && isActive) {
                    return false;
                  }
                }

                return true;
              });
            },

            get filteredSysMapData() {
              return this.sysMapData.filter(item => {
                // Category filter
                if (
                  this.sysMapFilters.category &&
                  item.category !== this.sysMapFilters.category
                ) {
                  return false;
                }

                // Left value filter
                if (
                  this.sysMapFilters.left &&
                  !item.left_value
                    .toLowerCase()
                    .includes(this.sysMapFilters.left.toLowerCase())
                ) {
                  return false;
                }

                // Right value filter
                if (
                  this.sysMapFilters.right &&
                  !item.right_value
                    .toLowerCase()
                    .includes(this.sysMapFilters.right.toLowerCase())
                ) {
                  return false;
                }

                // Status filter
                if (this.sysMapFilters.status) {
                  const isActive = item.in_used;
                  if (this.sysMapFilters.status === "active" && !isActive) {
                    return false;
                  }
                  if (this.sysMapFilters.status === "inactive" && isActive) {
                    return false;
                  }
                }

                return true;
              });
            }
          };
        };

        // Global error handlers to prevent unhandled promise rejections
        window.addEventListener("unhandledrejection", event => {
          utils.importantLog(
            "warn",
            "App",
            "Unhandled promise rejection:",
            event.reason
          );
          // Prevent the error from being logged to console as uncaught
          event.preventDefault();
        });

        window.addEventListener("error", event => {
          // Filter out extension-related errors that we can't control
          if (
            event.message &&
            event.message.includes("Extension context invalidated")
          ) {
            event.preventDefault();
            return;
          }
          if (
            event.message &&
            event.message.includes("message channel closed")
          ) {
            event.preventDefault();
            return;
          }
        });

        // ===================================================================
        // USER INTERACTION TRACKING (OAuth Security)
        // ===================================================================

        /**
         * Initialize user interaction tracking to prevent automatic OAuth calls
         * This tracks genuine user events to ensure OAuth is only triggered by user actions
         */
        function initUserInteractionTracking() {
          utils.debugLog(
            "ðŸ›¡ï¸ Initializing user interaction tracking for OAuth security"
          );

          // Track the last time a user performed a genuine interaction
          window._lastUserEventTime = 0;
          window._lastUserEventType = "none";
          window._handlingTrustedEvent = false;
          window._currentEventType = "none";

          // List of events that indicate genuine user interaction
          const userEvents = [
            "click",
            "keydown",
            "keyup",
            "mousedown",
            "mouseup",
            "touchstart",
            "touchend"
          ];

          userEvents.forEach(eventType => {
            document.addEventListener(
              eventType,
              event => {
                // Only track trusted events (not programmatically generated)
                if (event.isTrusted) {
                  window._lastUserEventTime = Date.now();
                  window._lastUserEventType = eventType;

                  // Set flag during event handling
                  window._handlingTrustedEvent = true;
                  window._currentEventType = eventType;

                  // Clear flag after a short delay
                  setTimeout(() => {
                    window._handlingTrustedEvent = false;
                    window._currentEventType = "none";
                  }, 100);
                }
              },
              true
            ); // Use capture phase to catch events early
          });

          utils.debugLog("âœ… User interaction tracking initialized");
        }

        // Note: Application initialization is now handled by Alpine.js x-init on body tag
        // This ensures single initialization and proper Alpine.js component lifecycle

        // Initialize Alpine store
        document.addEventListener("alpine:init", () => {
          Alpine.store("app", {
            currentView: "loading",
            currentPage: "sys-health",
            loadingMessage: "Initializing...",
            user: null,
            config: null,
            supabase: null,
            supabaseUrl: null,
            supabaseKey: null,
            pageData: {},
            availableRoles: [],
            isFirstTimeLogin: false, // Track if this is a genuine first-time login
            showPasswordRecoveryModal: false,
            _initialized: false, // Prevent multiple initializations

            // AuthService accessor for global use
            getAuthService() {
              return authService; // This refers to the authService variable in the IIFE scope
            },

            // Initialize Supabase configuration (DEPRECATED - now handled by ApplicationInitializer)
            // async initializeSupabase() {
            //   console.warn(
            //     "âš ï¸ initializeSupabase() is deprecated. Initialization is now handled by ApplicationInitializer."
            //   );
            //   // This method is kept for backward compatibility but should not be used
            //   return Promise.resolve();
            // },

            // Check initial auth state
            async checkInitialAuth() {
              // Initial auth state is now handled by AuthService
              // Just set a fallback timeout to show auth if nothing happens
              setTimeout(() => {
                if (this.currentView === "loading" && !this.user) {
                  utils.debugLog(
                    "No user detected after timeout, showing auth view"
                  );
                  this.currentView = "auth";
                }
              }, 5000);
            },

            // Initialize the app (DEPRECATED - now handled by ApplicationInitializer)
            // async init() {
            //   console.warn(
            //     'âš ï¸ Alpine.store("app").init() is deprecated. Initialization is now handled by ApplicationInitializer.'
            //   );
            //   // This method is kept for backward compatibility but should not be used
            //   return Promise.resolve();
            // },

            selectPage(pageId) {
              utils.debugLog(`ðŸ“„ Navigating to page: ${pageId}`);

              // Validate page ID
              const validPages = [
                "profile",
                "user-management",
                "onboarding",
                "sys-health",
                "rbac",
                "app-state",
                "request-state",
                "metadata"
              ];

              if (!validPages.includes(pageId)) {
                console.warn(
                  `Invalid page ID: ${pageId}. Falling back to sys-health.`
                );
                pageId = "sys-health";
              }

              // Update current page in store
              const oldPage = this.currentPage;
              this.currentPage = pageId;
              this.pageData = null; // Clear page data when switching pages

              // Save to localStorage for persistence
              try {
                app.pageNavigationService.saveCurrentPage(pageId);
              } catch (error) {
                console.warn("Could not save page to localStorage:", error);
              }

              // Force page update to ensure visibility
              setTimeout(() => {
                try {
                  // Try to use pageManager if available
                  if (
                    window.app &&
                    window.app.pageManager &&
                    typeof window.app.pageManager === "function"
                  ) {
                    const pageManagerInstance = window.app.pageManager();
                    if (pageManagerInstance.forcePageUpdate) {
                      pageManagerInstance.forcePageUpdate();
                    } else {
                      throw new Error("forcePageUpdate method not found");
                    }
                  } else {
                    throw new Error("pageManager not available");
                  }
                } catch (error) {
                  console.warn("Could not force page update:", error);
                  // Fallback: manually show the page
                  const pageElement = document.querySelector(
                    `[x-show="$store.app.currentPage === '${pageId}'"]`
                  );
                  if (pageElement) {
                    pageElement.removeAttribute("x-cloak");
                    pageElement.style.display = "block";
                    //   console.log(`âœ… Manually made page visible: ${pageId}`);
                    // } else {
                    //   console.warn(
                    //     `âŒ Could not find page element for: ${pageId}`
                    //   );
                  }
                }
              }, 50);

              utils.debugLog(
                `âœ… Successfully navigated to page: ${oldPage} â†’ ${pageId}`
              );
            },

            // Utility method for external page navigation
            navigateToPage(pageId) {
              this.selectPage(pageId);
            }
          });

          Alpine.store("auth", {
            loading: false,
            user: null
          });

          Alpine.store("toast", {
            show: false,
            message: "",
            class: "",
            icon: "info"
          });
        });

        // AuthService is embedded in this script, no need for external loading flag

        // Return all components
        return {
          devAdminApp,
          toastManager,
          authComponent,
          themeToggle,
          userMenu,
          pageManager,
          profilePage,
          userManagementPage,
          appStatePage,
          requestStatePage,
          sysHealthPage,
          onboardingPage,
          rbacPage,
          metadataPage,
          // Services
          apiService,
          pageNavigationService,
          pageManager,
          configService,
          toastService,
          utils,
          // Configs
          APP_CONFIG,
          TOAST_TYPES,
          AuthService
        };
      })();

      // Make specific components available globally for Alpine.js
      window.app = app;
    </script>
  </body>
</html>
